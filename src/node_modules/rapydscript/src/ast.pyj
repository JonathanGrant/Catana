"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under Apache 2.0 license:
    Copyright 2013 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

  RapydScript source code is originally based on UglifyJS2 (covered
  by BSD license). UglifyJS2 was written by Mihai Bazon
  <mihai.bazon@gmail.com>, who is its respective copyright holder.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 **********************************************************************
"""


def DEFNODE(type, props, methods, base):
    if arguments.length < 4:
        base = AST_Node

    if not props:
        props = []
    else:
        props = props.split(/\s+/)

    self_props = props
    if base and base.PROPS:
        props = props.concat(base.PROPS)

    code = "return function AST_" + type + "(props){ if (props) { "
    for i in range(props.length-1, -1, -1):
        code += "this." + props[i] + " = props." + props[i] + ";"

    proto = base and new base()
    if proto and proto.initialize or methods and methods.initialize:
        code += "this.initialize();"

    code += "}}"
    ctor = new Function(code)()
    if proto:
        ctor.prototype = proto
        ctor.BASE = base

    if base:
        base.SUBCLASSES.push(ctor)

    ctor.prototype.CTOR = ctor
    ctor.PROPS = props or None
    ctor.SELF_PROPS = self_props
    ctor.SUBCLASSES = []
    if type:
        ctor.prototype.TYPE = ctor.TYPE = type

    def memoized(f):
        return def(x):
            if not this.computedType:
                this.computedType = f.call(this, x)
            return this.computedType

    if methods:
        for method in dir(methods):
            if methods.hasOwnProperty(method):
                if method is 'resolveType':
                    # poor man's decorator until I get rid of this entire function
                    ctor.prototype[method] = memoized(methods[method])
                elif /^\$/.test(method):
                    ctor[method[1:]] = methods[method]
                else:
                    ctor.prototype[method] = methods[method]

    ctor.DEFMETHOD = def(name, method):
        this.prototype[name] = method

    return ctor

AST_Token = DEFNODE("Token", "type subtype value line col pos endpos newline_before comments_before file", {}, None)

AST_Node = DEFNODE("Node", "start end", {
    clone: def():
        return new this.CTOR(this)
    ,
    $documentation: "Base class of all AST nodes",
    $propdoc: {
        start: "[AST_Token] The first token of this node",
        end: "[AST_Token] The last token of this node"
    },
    _walk: def(visitor):
        return visitor._visit(this)
    ,
    walk: def(visitor):
        return this._walk(visitor)
    ,
    _dump: def(depth, omit, offset, include_name, compact):
        """
        Dump node structure, used for debugging:

            depth: how many nodes below to dump
            omit: properties to omit
            offset: padding offset to use
            include_name: whether to output the name of the node
            compact: use compact representation of the node
        """

        def out(string):
            pad = Array(offset + 1).join('  ')
            console.log(pad + string)

        if include_name:
            out(colored(this.TYPE, 'yellow'))

        for key in this:
            if key in omit:
                continue

            colored_key = colored(key + ': ', 'blue')
            value = this[key]
            if Array.isArray(value):
                if value.length:
                    out(' ' + colored_key + '[')
                    if depth > 1:
                        for element in value:
                            element._dump(depth-1, omit, offset+1, True, compact)
                    else:
                        for element in value:
                            out('   ' + colored(element.TYPE, 'yellow'))
                    out(' ]')
                else:
                    if not compact: out(' ' + colored_key + '[]')
            elif value not in [undefined, None]:
                if value.TYPE:
                    if value.TYPE is 'Token':
                        # tokens identify the lexical trigger for this node
                        if compact:
                            out(' ' + colored_key + colored(
                                value.TYPE + '(' +
                                value.file + ':' + value.line + ':' + value.col + ': ' +
                                value.value + ')'
                                , 'magenta'
                            ))
                        else:
                            out(' ' + colored_key + colored(value.TYPE, 'magenta'))
                            for property in value:
                                out('   ' + colored(property + ': ', 'blue') + value[property])
                    else:
                        # handle child nodes
                        out(' ' + colored_key + colored(value.TYPE, 'yellow'))
                        if depth > 1:
                            value._dump(depth-1, omit, offset+1, False, compact)
                elif type(value) is "string":
                    out(' ' + colored_key + colored('"' + value + '"', 'green'))
                elif type(value) is "number":
                    out(' ' + colored_key + colored(value, 'green'))
                elif type(value) is "boolean":
                    out(' ' + colored_key + colored(value, 'green'))
                else:
                    # unexpected object
                    out(' ' + colored_key + colored(value, 'red'))
            else:
                # none/undefined
                if not compact: out(' ' + colored_key + value)

    ,
    # a more user-friendly way to dump the AST tree than console.log
    dump: def(depth=2, omit=['start', 'end'], compact=True):
        return this._dump(depth, omit, 0, True, compact)
    ,
    computedType: None,
    resolveType: def(heap):
        """
        Function to resolve the final object type of the statement, if possible, override this on
        per-node basis
        """
        return "?"
}, None)

AST_Node.warn_function = None
AST_Node.warn = def(txt, props):
    if AST_Node.warn_function:
        AST_Node.warn_function(string_template(txt, props))

# -----[ statements ]-----
AST_Statement = DEFNODE("Statement", None, {
    $documentation: "Base class of all statements",
})

AST_Debugger = DEFNODE("Debugger", None, {
    $documentation: "Represents a debugger statement"
}, AST_Statement)

AST_Directive = DEFNODE("Directive", "value scope", {
    $documentation: 'Represents a directive, like "use strict";',
    $propdoc: {
        value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
        scope: "[AST_Scope/S] The scope that this directive affects"
    }
}, AST_Statement)

AST_SimpleStatement = DEFNODE("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
        body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.body._walk(visitor)
        )

}, AST_Statement)

def walk_body(node, visitor):
    if isinstance(node.body, AST_Statement):
        node.body._walk(visitor)
    elif node.body:
        for stat in node.body:
            stat._walk(visitor)

AST_Block = DEFNODE("Block", "body", {
    $documentation: "A body of statements (usually bracketed)",
    $propdoc: {
        body: "[AST_Statement*] an array of statements"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(this, def():
            walk_body(node, visitor)
        )
}, AST_Statement)

AST_BlockStatement = DEFNODE("BlockStatement", None, {
    $documentation: "A block statement"
}, AST_Block)

AST_EmptyStatement = DEFNODE("EmptyStatement", None, {
    $documentation: "The empty statement (empty block or simply a semicolon)",
    _walk: def(visitor):
        return visitor._visit(this)
}, AST_Statement)

AST_StatementWithBody = DEFNODE("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
        body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.body._walk(visitor)
        )
}, AST_Statement)

AST_LabeledStatement = DEFNODE("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
        label: "[AST_Label] a label definition"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.label._walk(visitor)
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_DWLoop = DEFNODE("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
        condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_Do = DEFNODE("Do", None, {
    $documentation: "A `do` statement"
}, AST_DWLoop)

AST_While = DEFNODE("While", None, {
    $documentation: "A `while` statement"
}, AST_DWLoop)

AST_ForIn = DEFNODE("ForIn", "init name object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        init: "[AST_Node] the `for/in` initialization code",
        name: "[AST_SymbolRef?] the loop variable, only if `init` is AST_Var",
        object: "[AST_Node] the object that we're looping through"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            node.object._walk(visitor)
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

AST_ForJS = DEFNODE("ForJS", "condition", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
        condition: "[AST_Verbatim] raw JavaScript conditional"
    },
}, AST_StatementWithBody)

AST_ListComprehension = DEFNODE("ListComprehension", "condition statement", {
    $documentation: "A list comprehension expression",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        statement: "[AST_Node] statement to perform on each element before returning it"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            if (node.condition) node.condition._walk(visitor)
            node.statement._walk(visitor)
        )
}, AST_ForIn)

AST_DictComprehension = DEFNODE("DictComprehension", "value_statement", {
    $documentation: "A dict comprehension expression",
    $propdoc: {
        value_statement: "[AST_Node] statement to perform on each value before returning it"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.init._walk(visitor)
            node.statement._walk(visitor)
            node.value_statement._walk(visitor)
            if node.condition:
                node.condition._walk(visitor)
        )
}, AST_ListComprehension)

AST_With = DEFNODE("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
        expression: "[AST_Node] the `with` expression"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.body._walk(visitor)
        )
}, AST_StatementWithBody)

# -----[ scope and functions ]-----
AST_Scope = DEFNODE("Scope", "docstring directives variables localvars functions parent_scope enclosed cname", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
        docstring: "[string?] docstring for this scope, if any",
        directives: "[string*/S] an array of directives declared in this scope",
        variables: "[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
        localvars: "[SymbolDef*] list of variables local to this scope",
        functions: "[Object/S] like `variables`, but only lists function declarations",
        parent_scope: "[AST_Scope?/S] link to the parent scope",
        enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
    }
}, AST_Block)

AST_Toplevel = DEFNODE("Toplevel", "globals baselib imports strict shebang import_order module_id exports submodules classes filename srchash", {
    $documentation: "The toplevel scope",
    $propdoc: {
        globals: "[Object/S] a map of name -> SymbolDef for all undeclared names",
        baselib: "[Object/s] a collection of used parts of baselib",
        imports: "[Object/S] a map of module_id->AST_Toplevel for all imported modules",
        nonlocalvars: "[String*] a list of all non-local variable names (names that come from the global scope)",
        strict: "[boolean/S] true if strict directive is in scope",
        shebang: "[string] If #! line is present, it will be stored here",
        import_order: "[number] The global order in which this scope was imported",
        module_id: "[string] The id of this module",
        exports: "[SymbolDef*] list of names exported from this module",
        submodules: "[string*] list of names exported from this module",
        classes: "[Object/S] a map of class names to AST_Class for classes defined in this module",
        filename: "[string] The absolute path to the file from which this module was read",
        srchash: "[string] SHA1 hash of source code, used for caching",
    },
    wrap_enclose: def(arg_parameter_pairs):
        self = this
        args = []
        parameters = []
        for pair in arg_parameter_pairs:
            split = pair.split(":")
            args.push(split[0])
            parameters.push(split[1])
        wrapped_tl = "(function(" + parameters.join(",") + "){ '$ORIG'; })(" + args.join(",") + ")"
        wrapped_tl = parse(wrapped_tl)
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(def before(node):
            if isinstance(node, AST_Directive) and node.value is "$ORIG":
                return MAP.splice(self.body)
        ))
        return wrapped_tl
    ,
    wrap_commonjs: def(name, export_all):
        self = this
        to_export = []
        if export_all:
            self.figure_out_scope()
            self.walk(new TreeWalker(def(node):
                if isinstance(node, AST_SymbolDeclaration) and node.definition().global:
                    if not find_if(def(n):
                        return n.name is node.name
                    , to_export):
                        to_export.push(node)
            ))
        wrapped_tl = "(function(exports, global){ global['" + name + "'] = exports; '$ORIG'; '$EXPORTS'; }({}, (function(){return this}())))"
        wrapped_tl = parse(wrapped_tl)
        wrapped_tl = wrapped_tl.transform(new TreeTransformer(def before(node):
            if isinstance(node, AST_SimpleStatement):
                node = node.body
                if isinstance(node, AST_String):
                    tmp_ = node.getValue()
                    if tmp_ is "$ORIG":
                        return MAP.splice(self.body)
                    elif tmp_ is "$EXPORTS":
                        body = []
                        for sym in to_export:
                            body.push(new AST_SimpleStatement({
                                body: new AST_Assign({
                                    left: new AST_Sub({
                                        expression: new AST_SymbolRef({
                                            name: "exports"
                                        }),
                                        property: new AST_String({
                                            value: sym.name
                                        })
                                    }),
                                    operator: "=",
                                    right: new AST_SymbolRef(sym)
                                })
                            }))
                        return MAP.splice(body)
        ))
        return wrapped_tl
}, AST_Scope)

AST_Splat = DEFNODE("Splat", "module key body", {
    $documentation: "Container for a naive import into the same scope, everything contained within the splat will be imported",
    $propdoc: {
        module: "[AST_SymbolVar] name of the module we're splatting",
        key: "[string] The key by which this module is stored in the global modules mapping",
        body: "[AST_TopLevel] parsed contents of the imported file",
    },
}, AST_Statement)

AST_Import = DEFNODE("Import", "module key alias argnames body", {
    $documentation: "Container for a single import",
    $propdoc: {
        module: "[AST_SymbolVar] name of the module we're importing",
        key: "[string] The key by which this module is stored in the global modules mapping",
        alias: "[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.",
        argnames: "[AST_ImportedVar*] names of objects to be imported",
        body: "[AST_TopLevel] parsed contents of the imported file",
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for arg in node.argnames:
                arg._walk(visitor)
        )
    ,
}, AST_Statement)

AST_Imports = DEFNODE('Imports', 'imports', {
    $documentation: "Container for a single import",
    $propdoc: {
        'imports': "[AST_Import+] array of imports",
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for imp in node.imports:
                imp._walk(visitor)
        )
    ,

}, AST_Statement)

AST_Decorator = DEFNODE("Decorator", "expression", {
    $documentation: "Class for function decorators",
    $propdoc: {
        expression: "[AST_Node] decorator expression"
    },
    _walk: def(visitor):
        if this.expression:
            this.expression.walk(visitor)
    ,
})

AST_Annotation = DEFNODE("Annotation", "expression", {
    $documentation: "Class for argument/return annotations",
    $propdoc: {
        expression: "[AST_Node] decorator expression"
    },
    _walk: def(visitor):
        if this.expression:
            this.expression.walk(visitor)
    ,
    resolveType: def(heap):
        # annotations are parsed differently from other elements in that it's not what's contained within the variable
        # that defines the type but rather the variable syntax itself
        def parse(obj):
            if isinstance(obj, AST_Array):
                # [Type]
                if obj.elements.length is 1: return '[' + parse(obj.elements[0]) + ']'
                return '[?]'
            if isinstance(obj, AST_Object):
                # {String:Type}
                if obj.properties.length is 1: return '{String:' + parse(obj.properties[0].value) + '}'
                return '{String:?}'
            if isinstance(obj, AST_SymbolRef):
                # Type
                # rename Array and Object/Dictionary to [?] and {String:?}
                return obj.name is 'Array' ? '[?]' : obj.name in ['Object', 'Dictionary'] ? '{String:?}' : obj.name
            if isinstance(obj, AST_Call):
                if isinstance(obj.expression, AST_SymbolRef) and obj.expression.name is 'Array' and obj.args.length is 1:
                    # Array(Type)
                    return '[' + parse(obj.args[0]) + ']'
                if isinstance(obj.expression, AST_SymbolRef) and obj.expression.name in ['Object', 'Dictionary']:
                    # Object(Type), Dictionary(Type), Object(String, Type), Dictionary(String, Type)
                    # in place of Dictionary you can also use Object keyword
                    # both formats are accepted as a convenience feature for developers
                    if 1 <= obj.args.length <= 2:
                        return '{String:' + parse(obj.args[-1]) + '}'
                    return '{String:?}'
            return '?'
        return parse(this.expression)
})

AST_Lambda = DEFNODE("Lambda", "name argnames kwargs uses_arguments decorators generator return_annotation", {
    $documentation: "Base class for functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this function/class/method",
        argnames: "[AST_SymbolFunarg*] array of arguments",
        kwargs: "[AST_SymbolFunarg?] kwargs symbol, if any",
        uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
        decorators: "[AST_Decorator*] function decorators, if any",
        generator: "[boolean] true if this is a generator function (false by default)",
        return_annotation: "[AST_Annotation?] the return type annotation provided (if any)"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():

            if node.decorators:
                for d in node.decorators:
                    d.walk(visitor)

            if node.name:
                node.name._walk(visitor)

            for arg in node.argnames:
                arg._walk(visitor)

            if node.argnames.starargs:
                node.argnames.starargs._walk(visitor)

            if node.kwargs:
                node.kwargs._walk(visitor)
            walk_body(node, visitor)
        )
}, AST_Scope)

AST_Accessor = DEFNODE("Accessor", None, {
    $documentation: "A setter/getter function"
}, AST_Lambda)

AST_Function = DEFNODE("Function", None, {
    $documentation: "A function expression",
    resolveType: def(heap):
        # I don't want to bother handling starargs yet, just say the signature is unknown
        if this.argnames.starargs: return 'Function'
        # this logic relies mostly on the resolveType within each annotation itself
        annotated = True
        args = []
        for arg in this.argnames:
            if arg.annotation:
                computedType = arg.annotation.resolveType(heap)
                if computedType:
                    args.push(computedType)
                else:
                    annotated = False
                    break
            else:
                annotated = False
                break

        if this.return_annotation:
            result = this.return_annotation.resolveType(heap)
            if not result:
                # it's ok not to have a return annotation, but not ok to have one that doesn't parse
                annotated = False

        signature = "Function"

        # we naively assume that argument annotations on function mean that the function is fully annotated, even if return is missing
        if annotated:
            signature += "(" + args.join(',') + ")"
            if result: signature += " -> " + result

        return signature
}, AST_Lambda)

AST_Class = DEFNODE("Class", "init name parent static external bound decorators module_id statements", {
    $documentation: "A class declaration",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this class",
        init: "[AST_Function] constructor for the class",
        parent: "[AST_Class?] parent class this class inherits from",
        "static": "[string*] list of static methods",
        external: "[boolean] true if class is declared elsewhere, but will be within current scope at runtime",
        bound: "[string*] hash of methods that need to be bound to behave correctly (function pointers)",
        decorators: "[AST_Decorator*] function decorators, if any",
        module_id: "[string] The id of the module this class is defined in",
        statements: "[AST_Node*] list of statements in the class scope (excluding method definitions)",
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.name._walk(visitor)
            walk_body(this, visitor)
            if node.parent:
                node.parent._walk(visitor)
        )
    ,
    resolveType: def(heap):
        return this.name.name
}, AST_Scope)

AST_Module = DEFNODE("Module", "name external decorators", {
    $documentation: "A module definition, meant to abstract a group of related classes and/or functions",
    $propdoc: {
        name: "[AST_SymbolDeclaration?] the name of this class",
        external: "[boolean] true if module is declared elsewhere, but will be within current scope at runtime",
        decorators: "[AST_Decorator*] module decorators, if any"
    }
}, AST_Scope)

AST_Method = DEFNODE("Method", "static", {
    $documentation: "A class method definition",
    $propdoc: {
        "static": "[boolean] true if method is static"
    }
}, AST_Lambda)

# -----[ JUMPS ]-----
AST_Jump = DEFNODE("Jump", None, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
}, AST_Statement)

AST_Exit = DEFNODE("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
        value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.value:
                node.value._walk(visitor)
        )
    ,
    resolveType: def(heap):
        return this.value.resolveType(heap)
}, AST_Jump)

AST_Return = DEFNODE("Return", None, {
    $documentation: "A `return` statement"
}, AST_Exit)

AST_Yield = DEFNODE("Yield", None, {
    $documentation: "A `yield` statement"
}, AST_Exit)

AST_Throw = DEFNODE("Throw", None, {
    $documentation: "A `throw` statement"
}, AST_Exit)

AST_LoopControl = DEFNODE("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
        label: "[AST_LabelRef?] the label, or null if none"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.label:
                node.label._walk(visitor)
        )
}, AST_Jump)

AST_Break = DEFNODE("Break", None, {
    $documentation: "A `break` statement"
}, AST_LoopControl)

AST_Continue = DEFNODE("Continue", None, {
    $documentation: "A `continue` statement"
}, AST_LoopControl)

# -----[ IF ]-----
AST_If = DEFNODE("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
        condition: "[AST_Node] the `if` condition",
        alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.body._walk(visitor)
            if node.alternative:
                node.alternative._walk(visitor)
        )
}, AST_StatementWithBody)

# -----[ SWITCH ]-----
AST_Switch = DEFNODE("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
        expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            walk_body(node, visitor)
        )
}, AST_Block)

AST_SwitchBranch = DEFNODE("SwitchBranch", None, {
    $documentation: "Base class for `switch` branches"
}, AST_Block)

AST_Default = DEFNODE("Default", None, {
    $documentation: "A `default` switch branch"
}, AST_SwitchBranch)

AST_Case = DEFNODE("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
        expression: "[AST_Node] the `case` expression"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            walk_body(node, visitor)
        )
}, AST_SwitchBranch)

# -----[ EXCEPTIONS ]-----
AST_Try = DEFNODE("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
        bcatch: "[AST_Catch?] the catch block, or null if not present",
        bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            walk_body(node, visitor)
            if node.bcatch:
                node.bcatch._walk(visitor)

            if node.bfinally:
                node.bfinally._walk(visitor)
        )
}, AST_Block)

AST_Catch = DEFNODE("Catch", None, {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {}
}, AST_Block)

AST_Except = DEFNODE("Except", "argname errors", {
    $documentation: "An `except` node for RapydScript, which resides inside the catch block",
    $propdoc: {
        argname: "[AST_SymbolCatch] symbol for the exception",
        errors: "[AST_SymbolVar*] error classes to catch in this block"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            if (node.argname):
                node.argname.walk(visitor)
            if (node.errors):
                for e in node.errors: e.walk(visitor)
            walk_body(node, visitor)
        )
}, AST_Block)

AST_Finally = DEFNODE("Finally", None, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
}, AST_Block)

# -----[ VAR/CONST ]-----
AST_Definitions = DEFNODE("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
        definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for def_ in node.definitions:
                def_._walk(visitor)
        )
}, AST_Statement)

AST_Var = DEFNODE("Var", None, {
    $documentation: "A `var` statement"
}, AST_Definitions)

AST_Const = DEFNODE("Const", None, {
    $documentation: "A `const` statement"
}, AST_Definitions)

AST_VarDef = DEFNODE("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
        name: "[AST_SymbolVar|AST_SymbolConst] name of the variable",
        value: "[AST_Node?] initializer, or null if there's no initializer"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.name._walk(visitor)
            if node.value:
                node.value._walk(visitor)
        )
})

# -----[ OTHER ]-----
AST_BaseCall = DEFNODE("BaseCall", "args", {
    $documentation: "A base class for function calls",
    $propdoc: {
        args: "[AST_Node*] array of arguments"
    }
})

AST_Call = DEFNODE("Call", "expression", {
    $documentation: "A function call expression",
    $propdoc: {
        expression: "[AST_Node] expression to invoke as function"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            for arg in node.args:
                arg._walk(visitor)
            if node.args.kwargs:
                for arg in node.args.kwargs:
                    arg[0]._walk(visitor)
                    arg[1]._walk(visitor)
            if node.args.kwarg_items:
                for arg in node.args.kwarg_items:
                    arg._walk(visitor)
        )
    ,
    resolveType: def(heap):
        if isinstance(this.expression, AST_SymbolRef):
            # this is where we get a bit devious, we use scope to infer the return type, if possible
            for scope in reversed(heap):
                if this.expression.name in scope.vars and '->' in scope.vars[this.expression.name][-1]:
                    # local var declarations, return result
                    return scope.vars[this.expression.name][-1].split('->')[1].trim()
                elif this.expression.name in scope.functions and '->' in scope.functions[this.expression.name]:
                    # local function declarations, return result
                    return scope.functions[this.expression.name].split('->')[1].trim()
                elif scope.type is "function" and this.expression.name is scope.name and scope.return:
                    # recursion, need to check return_annotation
                    # TODO: refactor this to minimize duplication
                    # helper method for detecting if this is a type annotation, and returning appropriate type
                    parse = def(variable):
                        wrap = {
                            "array": def(value): return "[" + value + "]";,
                            "dict": def(value): return "{String:" + value + "}";,
                            "base": def(value): return value
                        }
                        wrapper = "base"
                        if isinstance(variable, AST_Array):
                            # format: [Item]
                            if variable.elements.length is not 1:
                                # multiple items mentioned in array, not a case we can handle yet
                                return
                            wrapper = "array"
                            element = variable.elements[0]
                        elif isinstance(variable, AST_Call) and isinstance(variable.expression, AST_SymbolRef) and variable.expression.name is 'Array':
                            # format: Array(Item)
                            # alias for [Item]
                            if variable.args.length is not 1:
                                # multiple items mentioned in array, not a case we can handle yet
                                return
                            wrapper = "array"
                            element = variable.args[0]
                        elif isinstance(variable, AST_Object):
                            # format: {Item1:Item2}
                            if variable.properties.length is not 1:
                                # multiple items mentioned in hash, not a case we can handle yet
                                return
                            wrapper = "dict"
                            # key is always a string, ignore it
                            element = variable.properties[0].value
                        elif isinstance(variable, AST_Call) and isinstance(variable.expression, AST_SymbolRef) and variable.expression.name in ['Object', 'Dictionary']:
                            # format: Dictionary(Item2) or Dictionary(String,Item2), in place of Dictionary you can also use Object keyword
                            # both formats are accepted as a convenience feature for developers
                            # alias for {Item1:Item2}
                            if 1 <= variable.args.length <= 2:
                                element = variable.args[-1]
                                wrapper = "dict"
                            else:
                                return
                        else:
                            # format: Item
                            element = variable
                        if isinstance(element, AST_SymbolRef) and element.name in NATIVE_CLASSES:
                            # wrap element in dict/array if needed
                            return wrap[wrapper](element.name)
                        elif isinstance(element, AST_Array) or isinstance(element, AST_Object) or isinstance(element, AST_Call):
                            # potentially nested array/dict (i.e. array of dicts, array of arrays, dict of arrays, etc.)
                            result = parse(element)
                            if result: return wrap[wrapper](result)
                    result = parse(scope.return_annotation)
                    if result: return result
                # TODO: there is still a large set of functions we'll miss, address this later
        return "?"
}, AST_BaseCall)

AST_ClassCall = DEFNODE("ClassCall", "class super method static", {
    $documentation: "A function call expression",
    $propdoc: {
        "class": "[string] name of the class method belongs to",
        "super": "[boolean] this call can be replaced with a super() call",
        "method": "[string] class method being called",
        "static": "[boolean] defines whether the method is static"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            if node.expression: node.expression._walk(visitor)
            for arg in node.args:
                arg._walk(visitor)
            for arg in node.args.kwargs:
                arg[0]._walk(visitor)
                arg[1]._walk(visitor)
            for arg in node.args.kwarg_items:
                arg._walk(visitor)
        )
}, AST_BaseCall)

AST_New = DEFNODE("New", None, {
    $documentation: "An object instantiation. Derives from a function call since it has exactly the same properties"
}, AST_Call)

AST_Seq = DEFNODE("Seq", "car cdr", {
    $documentation: "A sequence expression (two comma-separated expressions)",
    $propdoc: {
        car: "[AST_Node] first element in sequence",
        cdr: "[AST_Node] second element in sequence"
    },
    $cons: def(x, y):
        seq = new AST_Seq(x)
        seq.car = x
        seq.cdr = y
        return seq
    ,
    $from_array: def(array):
        if array.length is 0:
            return None

        if array.length is 1:
            return array[0].clone()

        list = None
        for i in range(array.length-1, -1, -1):
            list = AST_Seq.cons(array[i], list)

        p = list
        while p:
            if p.cdr and not p.cdr.cdr:
                p.cdr = p.cdr.car
                break
            p = p.cdr
        return list
    ,
    to_array: def():
        p = this
        a = []
        while p:
            a.push(p.car)
            if p.cdr and not (isinstance(p.cdr, AST_Seq)):
                a.push(p.cdr)
                break
            p = p.cdr
        return a
    ,
    add: def(node):
        p = this
        while p:
            if not (isinstance(p.cdr, AST_Seq)):
                cell = AST_Seq.cons(p.cdr, node)
                return p.cdr = cell
            p = p.cdr
    ,
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.car._walk(visitor)
            if node.cdr:
                node.cdr._walk(visitor)
        )
})

AST_PropAccess = DEFNODE("PropAccess", "expression property", {
    $documentation: 'Base class for property access expressions, i.e. `a.foo`, `a["foo"]` or a[1:5]',
    $propdoc: {
        expression: "[AST_Node] the “container” expression",
        property: "[AST_Node|string] the property to access. For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
})

AST_Dot = DEFNODE("Dot", None, {
    $documentation: "A dotted property access expression",
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
        )
    ,
    resolveType: def(heap):
        # dot access can only unpack hashes
        containerType = this.expression.resolveType(heap)
        if containerType and containerType[0] is '{': return /\{\w+:(.*)\}/.exec(containerType)[1]
        return '?'
}, AST_PropAccess)

AST_Sub = DEFNODE("Sub", None, {
    $documentation: 'Index-style property access, i.e. `a["foo"]`',
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.property._walk(visitor)
        )
    ,
    resolveType: def(heap):
        # index-style access can unpack both hashes and arrays
        containerType = this.expression.resolveType(heap)
        if containerType:
            # unpack the array/hash
            if containerType[0] is '[' and isinstance(this.property, AST_Number): return /\[(.*)\]/.exec(containerType)[1]
            if containerType[0] is '{': return /\{\w+:(.*)\}/.exec(containerType)[1]
        return '?'
}, AST_PropAccess)

AST_Slice = DEFNODE("Slice", "property2 assignment", {
    $documentation: 'Index-style property access, i.e. `a[3:5]`',
    $propdoc: {
        property2: "[AST_Node] the 2nd property to access - typically ending index for the array.",
        assignment: "[AST_Node] The data being spliced in."
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
            node.property._walk(visitor)
            node.property2._walk(visitor)
        )
    ,
    resolveType: def(heap):
        # a slice of an iterable will be of same type as the iterable
        return this.expression.resolveType(heap)
}, AST_PropAccess)

AST_Unary = DEFNODE("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
        operator: "[string] the operator",
        expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.expression._walk(visitor)
        )
    ,
    resolveType: def(heap):
        if this.operator is "!": return "Boolean"
        if this.operator in ["-", "+"] and this.expression.resolveType(heap) is "Number": return "Number"
        return "?"
})

AST_UnaryPrefix = DEFNODE("UnaryPrefix", None, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
}, AST_Unary)

AST_UnaryPostfix = DEFNODE("UnaryPostfix", None, {
    $documentation: "Unary postfix expression, i.e. `i++`"
}, AST_Unary)

AST_Binary = DEFNODE("Binary", "left operator right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
        left: "[AST_Node] left-hand side expression",
        operator: "[string] the operator",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.left._walk(visitor)
            node.right._walk(visitor)
        )
    ,
    resolveType: def(heap):
        if not (this.left and this.right):
            # this.dump()
            return "?"
        left = this.left.resolveType(heap)
        right = this.left.resolveType(heap)
        if left is "Number" and right == "Number": return "Number"
        if left is "Boolean" and right == "Boolean" or this.operator in ['===', '!==', '>', '>=', '<', '<=']: return "Boolean" # technically real binary ops produce numbers here
        if left is "String" and this.operator is "+":
            # FIXME: for now allow this operation, in the future we will complain if types don't match
            return "String"
        return "?"
})

AST_Range = DEFNODE("Range", None, {
    $documentation: "Range node (to/til)",
    resolveType: def(heap): return "[Number]"
}, AST_Binary)

AST_DeepEquality = DEFNODE("DeepEquality", None, {
    $documentation: "Pythonic deep equality operator",
    resolveType: def(heap): return "Boolean"
}, AST_Binary)

AST_Conditional = DEFNODE("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
        condition: "[AST_Node]",
        consequent: "[AST_Node]",
        alternative: "[AST_Node]"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.condition._walk(visitor)
            node.consequent._walk(visitor)
            node.alternative._walk(visitor)
        )
    ,
    resolveType: def(heap):
        computedType = this.consequent.resolveType(heap)
        return computedType is this.alternative.resolveType(heap) ? computedType : "?"
})

AST_Assign = DEFNODE("Assign", None, {
    $documentation: "An assignment expression — `a = b + 5`"
    ,
    resolveType: def(heap):
        # for chained assignments
        if this.operator is "=":
            return this.right.resolveType(heap)
        return "?"
}, AST_Binary)

# -----[ LITERALS ]-----
AST_Array = DEFNODE("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
        elements: "[AST_Node*] array of elements"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for el in node.elements:
                el._walk(visitor)
        )
    ,
    resolveType: def(heap):
        # attempt to extract a consistent type within array
        if not this.elements.length: return "[?]"
        expected = this.elements[0].resolveType(heap)
        for element in this.elements[1:]:
            current = element.resolveType(heap)
            if current is not expected:
                if expected.indexOf("Function") is 0 and current.indexOf("Function") is 0: return "[Function]" # only the signatures don't match
                return "[?]"
        return "[" + expected + "]"
})

AST_TupleUnpack = DEFNODE("TupleUnpack", "elements right", {
    $documentation: "An object used to represent tuple unpacking",
    $propdoc: {
        elements: "[AST_Node*] array of elements being assigned to",
        right: "[AST_Node] right-hand side expression"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for el in node.elements:
                el._walk(visitor)
            node.right._walk(visitor)
        )
})

AST_Object = DEFNODE("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
        properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            for prop in node.properties:
                prop._walk(visitor)
        )
    ,
    resolveType: def(heap):
        # attempt to extract a consistent type within hashmap
        # for now we'll assume the key is always a string, because it can't yet be anything else
        if not this.properties.length: return "{String:?}"
        start = 0
        spread = None
        while isinstance(this.properties[start], AST_UnaryPrefix):
            # if proeprties start with spread operators, check them all for consistency, if possible
            spread = this.properties[start].expression.resolveType(heap)
            if "?" in spread: return "{String:?}"
            start += 1

        expected = this.properties[start].value.resolveType(heap)
        for element in this.properties[start+1:]:
            # now loop through remaining properties
            if isinstance(element, AST_UnaryPrefix):
                # another spread operator
                if spread:
                    if spread is not element.expression.resolveType(heap): return "{String:?}"
                else:
                    spread = element.expression.resolveType(heap)
            elif isinstance(element, AST_Accessor):
                # hashmap has getters/setters, ignore for now
                # if it's a setter, it has no return type anyway
                # if it's a getter, chances are it returns same type as objects stored inside (although that may be false)
                pass
            else:
                # regular element
                current = element.value.resolveType(heap)
                if current is not expected:
                    if expected.indexOf("Function") is 0 and current.indexOf("Function") is 0: return "{String:Function}" # only the signatures don't match
                    return "{String:?}"
        result = "{String:" + expected + "}"
        if spread:
            if spread is result: return result
            else: return "{String:?}"
        return result
})

AST_ObjectProperty = DEFNODE("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
        key: "[AST_Node] the property name or expression for computed key ",
        value: "[AST_Node] property value. For setters and getters this is an AST_Function.",
    },
    _walk: def(visitor):
        node = this
        return visitor._visit(node, def():
            node.key._walk(visitor)
            node.value._walk(visitor)
        )
})

AST_ObjectKeyVal = DEFNODE("ObjectKeyVal", None, {
    $documentation: "A key: value object property"
}, AST_ObjectProperty)

AST_ObjectSetter = DEFNODE("ObjectSetter", None, {
    $documentation: "An object setter property"
}, AST_Accessor)

AST_ObjectGetter = DEFNODE("ObjectGetter", None, {
    $documentation: "An object getter property"
}, AST_Accessor)

AST_Symbol = DEFNODE("Symbol", "scope name thedef", {
    $propdoc: {
        name: "[string] name of this symbol",
        scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
        thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols"
})

AST_SymbolAlias = DEFNODE("SymbolAlias", None, {
    $documentation: "An alias used in an import statement"
}, AST_Symbol)

AST_SymbolAccessor = DEFNODE("SymbolAccessor", None, {
    $documentation: "The name of a property accessor (setter/getter function)"
}, AST_Symbol)

AST_SymbolDeclaration = DEFNODE("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)",
    $propdoc: {
        init: "[AST_Node*/S] array of initializers for this declaration."
    }
}, AST_Symbol)

AST_SymbolVar = DEFNODE("SymbolVar", None, {
    $documentation: "Symbol defining a variable"
}, AST_SymbolDeclaration)

AST_SymbolNonlocal = DEFNODE("SymbolNonlocal", None, {
    $documentation: "A nonlocal declaration"
}, AST_SymbolDeclaration)

AST_ImportedVar = DEFNODE("ImportedVar", 'alias', {
    $documentation: "Symbol defining an imported symbol",
    $propdoc: {
        alias: "AST_SymbolAlias the alias for this imported symbol"
    }
}, AST_SymbolVar)

AST_SymbolConst = DEFNODE("SymbolConst", None, {
    $documentation: "A constant declaration"
}, AST_SymbolDeclaration)

AST_SymbolFunarg = DEFNODE("SymbolFunarg", 'annotation', {
    $documentation: "Symbol naming a function argument",
    $propdoc: {
        annotation: "[AST_Annotation?] annotation provided for this argument, if any"
    }
}, AST_SymbolVar)

AST_SymbolDefun = DEFNODE("SymbolDefun", None, {
    $documentation: "Symbol defining a function"
}, AST_SymbolDeclaration)

AST_SymbolLambda = DEFNODE("SymbolLambda", None, {
    $documentation: "Symbol naming a function expression"
}, AST_SymbolDeclaration)

AST_SymbolCatch = DEFNODE("SymbolCatch", None, {
    $documentation: "Symbol naming the exception in catch"
}, AST_SymbolDeclaration)

AST_Label = DEFNODE("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
        references: "[AST_LabelRef*] a list of nodes referring to this label"
    }
}, AST_Symbol)

AST_SymbolRef = DEFNODE("SymbolRef", "parens", {
    $documentation: "Reference to some symbol (not definition/declaration)",
    $propdoc: {
        parens: "[boolean/S] if true, this variable is wrapped in parentheses"
    },
    resolveType: def(heap):
        # this is where we get a bit devious, we use scope to infer the symbol, if possible
        for scope in reversed(heap):
            if this.name in scope.vars:
                return scope.vars[this.name][-1]    # last-assigned type
            if scope.args and this.name in scope.args:
                return scope.args[this.name]
        return "?"
}, AST_Symbol)

AST_SymbolClassRef = DEFNODE("SymbolClassRef", "class", {
    $documentation: "Reference to class symbol",
    $propdoc: {
        class: "[AST_SymbolDeclaration?] the name of this class",
    }
}, AST_Symbol)

AST_LabelRef = DEFNODE("LabelRef", None, {
    $documentation: "Reference to a label symbol"
}, AST_Symbol)

AST_This = DEFNODE("This", None, {
    $documentation: "The `this` symbol"
}, AST_Symbol)

AST_Constant = DEFNODE("Constant", None, {
    $documentation: "Base class for all constants",
    getValue: def():
        return this.value
})

AST_String = DEFNODE("String", "value modifier", {
    $documentation: "A string literal",
    $propdoc: {
        value: "[string] the contents of this string",
        modifier: "[string] string type modifier"
    },
    resolveType: def(): return "String"
}, AST_Constant)

AST_Verbatim = DEFNODE("Verbatim", "value", {
    $documentation: "Raw JavaScript code",
    $propdoc: {
        value: "[string] A string of raw JS code"
    }
}, AST_Constant)

AST_Number = DEFNODE("Number", "value", {
    $documentation: "A number literal",
    $propdoc: {
        value: "[number] the numeric value"
    },
    resolveType: def(): return "Number"
}, AST_Constant)

AST_Identifier = DEFNODE("Identifier", "value", {
    $documentation: "An identifier literal, used for unquoted property key",
    $propdoc: {
        value: "[string] the name of this key"
    },
    resolveType: def(): return "String"
}, AST_Constant)

AST_RegExp = DEFNODE("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
        value: "[RegExp] the actual regexp"
    },
    resolveType: def(): return "RegExp"
}, AST_Constant)

AST_Atom = DEFNODE("Atom", None, {
    $documentation: "Base class for atoms"
}, AST_Constant)

AST_Null = DEFNODE("Null", None, {
    $documentation: "The `null` atom",
    value: None,
    resolveType: def(): return None
}, AST_Atom)

AST_NaN = DEFNODE("NaN", None, {
    $documentation: "The impossible value",
    value: 0 / 0,
    resolveType: def(): return None
}, AST_Atom)

AST_Undefined = DEFNODE("Undefined", None, {
    $documentation: "The `undefined` value",
    value: void 0,
    resolveType: def(): return None
}, AST_Atom)

AST_Hole = DEFNODE("Hole", None, {
    $documentation: "A hole in an array",
    value: void 0,
    resolveType: def(): return None
}, AST_Atom)

AST_Infinity = DEFNODE("Infinity", None, {
    $documentation: "The `Infinity` value",
    value: 1 / 0,
    resolveType: def(): return "Number"
}, AST_Atom)

AST_Boolean = DEFNODE("Boolean", None, {
    $documentation: "Base class for booleans",
    resolveType: def(): return "Boolean"
}, AST_Atom)

AST_False = DEFNODE("False", None, {
    $documentation: "The `false` atom",
    value: False
}, AST_Boolean)

AST_True = DEFNODE("True", None, {
    $documentation: "The `true` atom",
    value: True
}, AST_Boolean)

# -----[ TreeWalker ]-----
def TreeWalker(callback):
    this.visit = callback
    this.stack = []

TreeWalker.prototype = {
    _visit: def(node, descend):
        this.stack.push(node)
        ret = this.visit(node, (descend ? def(): descend.call(node); : noop))
        if not ret and descend:
            descend.call(node)

        this.stack.pop()
        return ret
    ,
    parent: def(n):
        return this.stack[this.stack.length - 2 - (n or 0)]
    ,
    push: def(node):
        this.stack.push(node)
    ,
    pop: def():
        return this.stack.pop()
    ,
    self: def():
        return this.stack[this.stack.length - 1]
    ,
    find_parent: def(type):
        stack = this.stack
        for i in range(stack.length-1, -1, -1):
            x = stack[i]
            if isinstance(x, type):
                return x
    ,
    in_boolean_context: def():
        stack = this.stack
        i = stack.length
        self = stack[i -= 1]
        while i > 0:
            p = stack[i -= 1]
            if isinstance(p, AST_If) and p.condition is self
            or isinstance(p, AST_Conditional) and p.condition is self
            or isinstance(p, AST_DWLoop) and p.condition is self
            or isinstance(p, AST_UnaryPrefix) and p.operator is "!" and p.expression is self:
                return True
            if not (isinstance(p, AST_Binary) and (p.operator is "&&" or p.operator is "||")):
                return False
            self = p
    ,
    loopcontrol_target: def(label):
        stack = this.stack
        if label:
            for i in range(stack.length-1, -1, -1):
                x = stack[i]
                if isinstance(x, AST_LabeledStatement) and x.label.name is label.name:
                    return x.body
        else:
            for i in range(stack.length-1, -1, -1):
                x = stack[i]
                if isinstance(x, AST_Switch) or isinstance(x, AST_ForIn) or isinstance(x, AST_DWLoop):
                    return x
}
