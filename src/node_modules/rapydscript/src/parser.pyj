"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under Apache 2.0 license:
    Copyright 2013 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

  RapydScript source code is originally based on UglifyJS2 (covered
  by BSD license). UglifyJS2 was written by Mihai Bazon
  <mihai.bazon@gmail.com>, who is its respective copyright holder.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

**********************************************************************
"""


RAPYD_PREFIX = "ՐՏ"     # previously _$rapyd$_
NATIVE_CLASSES = {
    # javascript
    'Image': {},
    'RegExp': {},
    'Error': {},
    'Object': {
        static: [
            "assign",               # ES6
            "getOwnPropertyNames",
            "keys",
            "create",
            "defineProperty",
            "defineProperties",
            "getPrototypeOf",       # ES6
            "setPrototypeOf",       # ES6
        ]
    },
    'String': {
        static: [ "fromCharCode" ]
    },
    'Array': {
        static: [ "isArray", "from", "of" ]
    },
    'Number': {
        static: [ "isFinite", "isNaN" ]
    },
    'Function': {},
    'Date': {
        static: [ "UTC", "now", "parse" ]
    },
    'Boolean': {},
    'ArrayBuffer': {},
    'DataView': {},
    'Float32Array': {},
    'Float64Array': {},
    'Int16Array': {},
    'Int32Array': {},
    'Int8Array': {},
    'Uint16Array': {},
    'Uint32Array': {},
    'Uint8Array': {},
    'Uint8ClampedArray': {},
    'Map': {},      # ES6
    'WeakMap': {},  # ES6
    'Set': {},      # ES6
    'WeakSet': {},  # ES6

    # baselib
    "AssertionError": {},
    "IndexError": {},
    "KeyError": {},
    "TypeError": {},
    "ValueError": {},
}
COMMON_STATIC = [ "call", "apply", "bind", "toString" ]

CLASS_MAP = {}      # top-level classes will be populated into here

# detect common python stdlib methods - these will be auto-injected into the code when called
BASELIB = {}
STDLIB = [
    "abs",
    "bin",
    "cmp",
    "chr",
    "dir",
    "hex",
    "max",
    "min",
    "merge",
    "mixin",
    "print",
    "range",
    "reduce",
    "getattr",
    "setattr",
    "hasattr",

    # unique to RapydScript
    "eq",
    "bind",
    "rebind_all",

    # list operations
    "all",
    "any",
    "enumerate",
    "filter",
    "len",
    "map",
    "reversed",
    "sum",
    "zip",

    # errors
    "AssertionError",
    "IndexError",
    "KeyError",
    "TypeError",
    "ValueError",
]


def has_simple_decorator(decorators, name):
    remove = []
    for JS('var i = 0; i < decorators.length; i++'):
        s = decorators[i]
        if isinstance(s, AST_SymbolRef) and not s.parens and s.name is name:
            remove.push(i)
    if remove.length:
        remove.reverse()
        for JS('var i = 0; i < remove.length; i++'):
            decorators.splice(remove[i], 1)
        return True
    return False

# -----[ Parser (constants) ]-----
UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+",
    "*",    # eventually I'll rename this to ...
    "@"
])


ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ])

PRECEDENCE = (def(a, ret):
    for i in range(a.length):
        b = a[i]
        for j in range(b.length):
            ret[b[j]] = i+1
    return ret
)([
    # lowest precedence
    [ "||" ],
    [ "&&" ],
    [ "|" ],
    [ "^" ],
    [ "&" ],
    [ "==", "===", "!=", "!==" ],
    [ "<", ">", "<=", ">=", "in", "instanceof" ],
    [ ">>", "<<", ">>>" ],
    [ "+", "-" ],
    [ "*", "/", "//", "%" ],
    [ "**" ]
    # highest precedence
], {})

STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ])

ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ])


# -----[ Parser ]-----
def parse($TEXT, options):
    options = defaults(options, {
        strict: False,          # whether to use strict JavaScript mode
        filename: None,         # name of the file being parsed
        auto_bind: False,       # whether auto-binding of methods to classes is enabled
        module_id: '__main__',  # The id of the module being parsed
        es6: False,             # whether we're using EcmaScript 6 mode
        toplevel: None,         # existing tree to append to, if None, new tree will be started
        import_dirs: [],        # List of directories to scan for imports
        dropDecorators: [],     # Decorators to omit from compilation
        dropImports: [],        # Imports to omit from compilation
        classes: None           # Map of class names to AST_Class that are available in the global namespace (used by the REPL)
    })
    module_id = options.module_id

    # fallthrough order: --> relative basedir, user-specified import dirs, standard libdir
    import_dirs = options.import_dirs[:]
    if options.libdir: import_dirs.push(options.libdir)
    if options.basedir: import_dirs.unshift(options.basedir)

    IMPORTED = options.IMPORTED or {}
    IMPORTING = options.IMPORTING or {}
    IMPORTING[module_id] = True

    S = {
        input: (typeof $TEXT is "string" ? tokenizer($TEXT, options.filename) : $TEXT),
        token: None,            # current token being scanned
        prev: None,             # previous token
        peeked: None,           # cached version of next token
        in_directives: True,    # per-scope directive, i.e. "use strict"
        in_loop: 0,             # number of loops we're currently nested inside of
        in_scope: [ {           # relevant context for given scope
            type: None,         # scope type
            vars: {},           # variables in this scope
            nonlocal: {},       # variables shared with outer scope
            functions: {},      # list of functions declared in this scope and their signatures
            classes: {}         # classes visible from this scope
        } ],
        labels: [],
        decorators: [],         # decorators we've most-recently seen, these get reset as soon as we see function body
        in_seq: False,          # whether we're currently parsing a sequence
        in_decorator: False     # whether we're currently parsing a decorator
    }

    if options.classes:
        for cname in options.classes:
            obj = options.classes[cname]
            S.in_scope[0].classes[cname] = {
                'static': obj.static,
                'bound': obj.bound
            }

    S.token = next()

    def is_(type, value):
        return is_token(S.token, type, value)

    def peek():
        return S.peeked or (S.peeked = S.input())

    def next():
        S.prev = S.token
        if S.peeked:
            # next token is already cached, reuse it
            S.token = S.peeked
            S.peeked = None
        else:
            # process next token
            S.token = S.input()

        S.in_directives = S.in_directives and (S.token.type is "string" or is_("punc", ";"))
        return S.token

    def prev():
        return S.prev

    def croak(msg, line, col, pos, is_eof):
        # note: undefined means nothing was passed in, None/null means a null value was passed in
        ctx = S.input.context()
        js_error(msg, ctx.filename, (line is not undefined ? line : ctx.tokline),
                 (col is not undefined ? col : ctx.tokcol), (pos is not undefined ? pos : ctx.tokpos), is_eof)

    def token_error(token, msg):
        is_eof = (token.type is 'eof') ? true : false
        croak(msg, token.line, token.col, undefined, is_eof)

    def unexpected(token):
        if token is undefined:
            token = S.token
        token_error(token, "Unexpected token: " + token.type + " «" + token.value + "»")

    def expect_token(type, val):
        if is_(type, val):
            return next()
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" +
                    ", expected " + type + " «" + val + "»")

    def expect(punc):
        return expect_token("punc", punc)

    def can_insert_semicolon():
        return not options.strict and (S.token.newline_before or is_("eof") or is_("punc", "}"))

    def semicolon():
        if is_("punc", ";"):
            next()
            S.token.newline_before = True

    def parenthesised():
        expect("(")
        exp = expression(True)
        expect(")")
        return exp

    def embed_tokens(parser):
        return def():
            start = S.token
            expr = parser()
            if expr is undefined:
                unexpected()
            end = prev()
            expr.start = start
            expr.end = end
            return expr

    def is_nested_comparison(stmt):
        """
        Check if the statement is a nested comparison
        """
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True,
            "===": True,
            "!==": True
        }
        if isinstance(stmt, AST_Binary) and stmt.operator in comparators \
                and isinstance(stmt.left, AST_Binary) and stmt.left.operator in comparators:
            return True
        else:
            return False

    def scan_for_top_level_callables(body):
        ans = []
        # Get the named functions and classes
        if Array.isArray(body):
            for name in dir(body):
                obj = body[name]
                if isinstance(obj, AST_Function) or isinstance(obj, AST_Class):
                    if obj.name:
                        ans.push(obj.name)
                    else:
                        token_error(obj.start, "Top-level functions must have names")
                else:
                    # skip inner scopes
                    if isinstance(obj, AST_Scope):
                        continue
                    for x in ['body', 'alternative']:
                        opt = obj[x]
                        if opt:
                            ans = ans.concat(scan_for_top_level_callables(opt))

                        if isinstance(opt, AST_Assign) and not (isinstance(opt.right, AST_Scope)):
                            ans = ans.concat(scan_for_top_level_callables(opt.right))
        elif body.body:
            # recursive descent into wrapper statements that contain body blocks
            ans = ans.concat(scan_for_top_level_callables(body.body))
            if body.alternative:
                ans = ans.concat(scan_for_top_level_callables(body.alternative))

        return ans


    @embed_tokens
    def statement():
        if is_("operator", "/") or is_("operator", "/="):
            S.peeked = None
            S.token = S.input(S.token.value[1:])

        tmp_ = S.token.type
        if tmp_ is "string":
            dir = S.in_directives
            stat = simple_statement()
            # XXXv2: decide how to fix directives
            if dir and isinstance(stat.body, AST_String) and not is_("punc", ","):
                return new AST_Directive({
                    value: stat.body.value
                })

            return stat
        elif tmp_ is "shebang":
            tmp_ = S.token.value
            next()
            return new AST_Directive({
                value: tmp_
            })
        elif tmp_ is "num" or tmp_ is "regexp" or tmp_ is "operator" or tmp_ is "atom":
            return simple_statement()
        elif tmp_ is "punc":
            tmp_ = S.token.value
            if tmp_ is ":":
                return new AST_BlockStatement({
                    start: S.token,
                    body: block_(),
                    end: prev()
                })
            elif tmp_ is "{" or tmp_ is "[" or tmp_ is "(":
                return simple_statement()
            elif tmp_ is ";":
                next()
                return new AST_EmptyStatement()
            else:
                unexpected()
        elif tmp_ is "name":
            if S.token.value in ['set', 'get']:
                if not options.es6: croak("Class getters/setters require ES6 compilation mode")
                type = S.token.value
                start = S.token.start
                next()
                return accessor_(type, start, True)
            return (is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement())
        elif tmp_ is "keyword":
            tmp_ = S.token.value

            if ES6_KEYWORDS(tmp_) and not options.es6:
                token_error(prev(), "«" + tmp_ + "» keyword not supported with ES5 output, use --ecmascript6 compilation flag")

            next()
            if tmp_ is "break":
                return break_cont(AST_Break)
            elif tmp_ is "continue":
                return break_cont(AST_Continue)
            elif tmp_ is "debugger":
                semicolon()
                return new AST_Debugger()
            elif tmp_ is "do":
                return new AST_Do({
                    body: in_loop(statement),
                    condition: def():
                        expect(".")
                        expect_token("keyword", "while")
                        tmp = expression(True)
                        semicolon()
                        return tmp
                    .call(this)
                })
            elif tmp_ is "while":
                return new AST_While({
                    condition: expression(True),
                    body: in_loop(statement)
                })
            elif tmp_ is "for":
                if is_("name", "JS"):
                    return for_js()
                return for_()
            elif tmp_ is "from":
                return import_(True)
            elif tmp_ is "import":
                return import_(False)
            elif tmp_ is "class":
                BASELIB["extends"] = True
                if options.auto_bind:
                    BASELIB["rebind_all"] = True
                    BASELIB["bind"] = True  # used by rebind_all
                return class_()
            elif tmp_ is "def":
                start = prev()
                func = function_(S.in_scope[-1].type is "class" ? S.in_scope[-1].name : False)
                func.start = start
                func.end = prev()
                chain = subscripts(func, True)
                if chain is func:
                    return func
                else:
                    return new AST_SimpleStatement({
                        start: start,
                        body: chain,
                        end: prev()
                    })
            elif tmp_ is "if":
                return if_()
            elif tmp_ is "pass":
                semicolon()
                return new AST_EmptyStatement()
            elif tmp_ is "return" or tmp_ is "yield":
                if S.in_scope[-1].type is not "function":
                    croak("'return' outside of function")

                if tmp_ is "yield":
                    S.in_scope[-1].generator = True
                    ctor = AST_Yield
                else:
                    ctor = AST_Return

                result = new ctor({
                    value: (is_("punc", ";") ?
                        (def():
                            semicolon()
                            return None
                        )() : (can_insert_semicolon() ? None
                            : (def():
                                tmp = expression(True)
                                semicolon()
                                return tmp
                            )()
                        )
                    )
                })
                # check if user violated a contract they agreed to follow
                if (S.in_scope[-1].return_annotation):
                    expectedType = S.in_scope[-1].return_annotation.resolveType(S.in_scope)
                    actualType = result.resolveType(S.in_scope)
                    if actualType not in [expectedType, '?']:
                        croak("Type annotation states that function returns " + expectedType + ", actual returned type is " + actualType + "")
                return result
            elif tmp_ is "switch":
                return new AST_Switch({
                    expression: parenthesised(),
                    body: in_loop(switch_body_)
                })
            elif tmp_ is "raise":
                if S.token.newline_before:
                    return new AST_Throw({
                        value: new AST_SymbolCatch({
                            name: "ՐՏ_Exception"
                        })
                    })

                tmp = expression(True)
                semicolon()
                return new AST_Throw({
                    value: tmp
                })
            elif tmp_ is "try":
                return try_()
            elif tmp_ is "nonlocal":
                tmp = nonlocal_()
                semicolon()
                return tmp
            elif tmp_ is "const":
                tmp = const_()
                semicolon()
                return tmp
            elif tmp_ is "with":
                return new AST_With({
                    expression: parenthesised(),
                    body: statement()
                })
            else:
                unexpected()

    def labeled_statement():
        label = as_symbol(AST_Label)
        if find_if(def(l):
            return l.name is label.name
        , S.labels):
            # ECMA-262, 12.12: An ECMAScript program is considered
            # syntactically incorrect if it contains a
            # LabelledStatement that is enclosed by a
            # LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice")

        expect(":")
        S.labels.push(label)
        stat = statement()
        S.labels.pop()
        return new AST_LabeledStatement({
            body: stat,
            label: label
        })

    def simple_statement(tmp):
        tmp = expression(True)
        semicolon()
        return new AST_SimpleStatement({
            body: tmp
        })

    def break_cont(type):
        label = None
        if not can_insert_semicolon():
            label = as_symbol(AST_LabelRef, True)

        if label is not None:
            if not find_if(def(l):
                return l.name is label.name
            , S.labels):
                croak("Undefined label " + label.name)

        elif S.in_loop is 0:
            croak(type.TYPE + " not inside a loop or switch")

        semicolon()
        return new type({
            label: label
        })

    def seq_to_array(seq):
        # convert AST_Seq into AST_Array
        return new AST_Array({
            start: seq.start,
            elements: seq.to_array(),
            end: seq.end
        })

    def for_(list_comp):
        #        expect("(");
        init = None
        if not is_("punc", ";"):
            init = expression(True, True)
            # standardize AST_Seq into array now for consistency
            if isinstance(init, AST_Seq):
                init = seq_to_array(init)

            if is_("operator", "in"):
                if isinstance(init, AST_Var) and init.definitions.length > 1:
                    croak("Only one variable declaration allowed in for..in loop")
                next()
                return for_in(init, list_comp)

        unexpected()

    def for_in(init, list_comp):
        lhs = isinstance(init, AST_Var) ? init.definitions[0].name : None
        obj = expression(True)

        # mark iterator variable as local
        if isinstance(init, AST_Array):
            for i, element in enumerate(init.elements):
                value = None
                if isinstance(obj, AST_Call) and isinstance(obj.expression, AST_SymbolRef) and obj.expression.name is 'enumerate':
                    # FIXME: instead of doing this hack, annotate all of baselib and have compiler rely on it
                    # a naive assumption that user won't overwrite inbuilt functions
                    if i == 0: value = "Number"
                mark_local_assignment(element, value)
        else:
            # infer object type for the iteration sequence
            value = None
            if isinstance(obj, AST_Call) and isinstance(obj.expression, AST_SymbolRef) and obj.expression.name is 'range':
                # FIXME: instead of doing this hack, annotate all of baselib and have compiler rely on it
                # a naive assumption that user won't overwrite inbuilt functions
                value = "Number"
            mark_local_assignment(init, value)

        BASELIB["iterable"] = True
        if list_comp:
            return {
                init: init,
                name: lhs,
                object: obj
            }

        return new AST_ForIn({
            init: init,
            name: lhs,
            object: obj,
            body: in_loop(statement)
        })

    # A native JavaScript for loop - for JS("var i=0; i<5000; i++"):
    def for_js():
        condition = expression(True, True)
        return new AST_ForJS({
            condition: condition,
            body: in_loop(statement)
        })

    # scan function/class body for nested class declarations
    def get_class_in_scope(expr):
        # TODO: Currently if a local variable shadows a class name defined in
        # an outerscope, the logic below will identify that variable as a
        # class. This bug was always present. Fixing it will require the parser
        # to maintain a list of local variables for every AST_Scope and provide
        # an easy way to walk the ast tree upwards.
        if isinstance(expr, AST_SymbolRef):
            # check Native JS classes
            if expr.name in NATIVE_CLASSES:
                return NATIVE_CLASSES[expr.name]

            # traverse in reverse to check local variables first
            for s in range(S.in_scope.length-1, -1, -1):
                if expr.name in S.in_scope[s].classes:
                    return S.in_scope[s].classes[expr.name]

        elif isinstance(expr, AST_Dot):
            referenced_path = []
            # this one is for detecting classes inside modules and eventually nested classes
            while isinstance(expr, AST_Dot):
                referenced_path.unshift(expr.property)
                expr = expr.expression
            if isinstance(expr, AST_SymbolRef):
                referenced_path.unshift(expr.name)
                # now 'referenced_path' should contain the full path of potential class
                if len(referenced_path) > 1:
                    class_name = referenced_path.join('.')
                    for s in range(S.in_scope.length-1, -1, -1):
                        if class_name in S.in_scope[s].classes:
                            return S.in_scope[s].classes[class_name]
        return False

    def do_import(key):
        if key in IMPORTED: return  # we'll reuse the original imported code
        if IMPORTING[key]:          # cyclical import
            raise ImportError('Detected a recursive import of: ' + key + ' while importing: ' + module_id)

        # Ensure that the package containing this module is also imported
        package_module_id = key.split('.')[:-1].join('.')
        if len(package_module_id) > 0:
            do_import(package_module_id)

        def safe_read(base_path):
            for i, path in enumerate([base_path + '.pyj', base_path + '/__init__.pyj']):
                try:
                    return [options.readfile(path, "utf-8"), path]
                except as e:
                    if e.code is 'ENOENT' or e.code is 'EPERM' or e.code is 'EACCESS':
                        if i is 1:
                            return None, None
                    if i is 1:
                        raise

        src_code = filename = None
        modpath = key.replace('.', '/')

        for location in import_dirs:
            if location:
                data, filename = safe_read(location + '/' + modpath)
                if data is not None:
                    src_code = data
                    break
        if src_code is None:
            raise "Failed Import: '" + key + "' module doesn't exist in any of the import directories: " + import_dirs.join(', ')
        contents = parse(src_code, {
            filename: filename,
            toplevel: None,
            readfile: options.readfile,
            basedir: options.basedir,
            libdir: options.libdir,
            module_id: key,
            IMPORTED: IMPORTED,
            IMPORTING: IMPORTING,
            auto_bind: options.auto_bind,
            es6: options.es6,
            import_dirs: options.import_dirs,
            dropDecorators: options.dropDecorators,
            dropImports: options.dropImports,
        })
        if len(package_module_id) > 0:
            IMPORTED[package_module_id].submodules.push(key)


    def import_(from_import):
        ans = new AST_Imports({'imports':[]})
        while True:
            tmp = name = expression(False)
            key = ''
            while isinstance(tmp, AST_Dot):
                key = "." + tmp.property + key
                tmp = tmp.expression
            key = tmp.name + key
            if not keepDecoratorOrImport(key, True):
                return new AST_EmptyStatement({
                    start: prev(),
                    end: prev()
                })
            alias = None
            if not from_import and is_('keyword', 'as'):
                next()
                alias = as_symbol(AST_SymbolAlias)
            imp = new AST_Import({
                'module': name,
                'key': key,
                'alias': alias,
                'argnames':None,
                'body':def():
                    return IMPORTED[key]
            })
            ans.imports.push(imp)
            if from_import:
                break
            if is_('punc', ','):
                next()
            else:
                break

        for imp in ans['imports']:
            do_import(imp.key)
            classes = IMPORTED[key].classes
            if from_import:
                expect_token("keyword", "import")
                imp.argnames = argnames = []
                while True:
                    aname = as_symbol(AST_ImportedVar)
                    if is_('keyword', 'as'):
                        next()
                        aname.alias = as_symbol(AST_SymbolAlias)
                    argnames.push(aname)
                    if is_('punc', ','):
                        next()
                    else:
                        break

                # Put imported class names in the outermost scope
                for argvar in argnames:
                    obj = classes[argvar.name]
                    if obj:
                        key = (argvar.alias) ? argvar.alias.name : argvar.name
                        S.in_scope[-1].classes[key] = { "static": obj.static, "bound": obj.bound }
            else:
                for i in dir(classes):
                    obj = classes[i]
                    if isinstance(obj, AST_Class):
                        key = (imp.alias) ? imp.alias.name : imp.key
                        S.in_scope[-1].classes[key + '.' + obj.name.name] = { "static": obj.static, "bound": obj.bound }

        return ans


    def class_():
        start = prev()
        name = as_symbol(AST_SymbolDefun)
        if not name:
            unexpected()

        # detect external classes
        externaldecorator = has_simple_decorator(S.decorators, 'external')

        class_details = {
            "static": [],
            "bound": {}
        }

        # class setup
        parent = None
        docstring = None
        definition = new AST_Class({
            start: start,
            name: name,
            module_id:module_id,
            parent: (def():
                if is_("punc", "("):
                    next()
                    if is_('punc', ')'):
                        S.in_parenthesized_expr = False
                        next()
                        return None
                    atom = expr_atom(False)
                    expect(")")
                    nonlocal parent
                    parent = atom.name
                    return atom
                else:
                    return None
            )(),
            localvars: [],
            static: class_details.static,
            external: externaldecorator,
            bound: class_details.bound,
            statements: [],
            decorators: (def():
                d = []
                for decorator in S.decorators:
                    if decorator is 'kwargs':
                        BASELIB['kwargs'] = True
                    d.push(new AST_Decorator({
                        expression: decorator
                    }))
                S.decorators = []
                return d
            )(),
            body: (def(loop, labels):
                # navigate to correct location in the module tree and append the class

                # state "push"
                S.in_scope[-1].classes[name.name] = class_details
                S.in_scope.push({
                    type: "class",
                    name: name.name,
                    parent: parent,
                    nonlocal: {},
                    functions: {},
                    vars: {},
                    classes: {}
                })
                S.in_directives = True
                S.in_loop = 0
                S.labels = []

                a = block_()

                nonlocal docstring
                docstring = S.in_scope[-1].docstring

                # state "pop"
                S.in_scope.pop()
                S.in_loop = loop
                S.labels = labels

                return a
            )(S.in_loop, S.labels),
            docstring: docstring,
            end: prev()
        })

        # find the constructor
        for i in dir(definition.body):
            stmt = definition.body[i]
            if isinstance(stmt, AST_Method) and stmt.name.name is "__init__":
                definition.init = stmt
                break

        # find class variables
        class_var_names = {}
        # Ensure that if a class variable refers to another class variable in
        # its initialization, the referenced variables' names are correctly
        # mangled.
        def walker():
            this._visit = def(node, descend):
                if isinstance(node, AST_Method):
                    class_var_names[node.name.name] = True
                    return
                elif isinstance(node, AST_Assign) and isinstance(node.left, AST_SymbolRef):
                    class_var_names[node.left.name] = True

                for child in node:
                    if isinstance(node[child], AST_SymbolRef) and Object.prototype.hasOwnProperty.call(class_var_names, node[child].name):
                        node[child] = new AST_SymbolClassRef({
                            'class': name,
                            'name': node[child].name
                        })
                if descend:
                    descend.call(node)
        visitor = new walker()

        for stmt in definition.body:
            if not isinstance(stmt, AST_Class) and not isinstance(stmt, AST_Method):
                stmt.walk(visitor)
                definition.statements.push(stmt)

        if S.in_scope.length is 1:  # we're in top level
            CLASS_MAP[definition.name.name] = definition

        return definition

    def function_(in_class, ctor):
        start = prev()
        is_accessor = ctor is AST_ObjectGetter or ctor is AST_ObjectSetter
        name = (is_("name") ? as_symbol((in_class ? AST_SymbolDefun : (is_accessor ? AST_SymbolAccessor : AST_SymbolLambda))) : (is_accessor and (is_("string") or is_("num")) ? as_atom_node() : None))
        if in_class and not name:
            unexpected()

        generator = False           # whether this function is a generator
        localvars = None            # hash of local vars assigned to within the function
        staticmethod = False        # whether this function declares itseld as a static method
        function_args = {}          # hash of arguments this function sees
        return_annotation = None    # return annotation for the function, if any

        # special decorators are decorators that have special meaning to the compiler
        has_special_decorator = def(name): return has_simple_decorator(S.decorators, name)

        if in_class:
            if has_special_decorator("staticmethod"):
                S.in_scope[-2].classes[in_class].static.push(name.name)
                staticmethod = True
            if has_special_decorator("bind") or name.name is not "__init__" and options.auto_bind:
                BASELIB["bind"] = True
                S.in_scope[-2].classes[in_class].bound[name.name] = True

        expect("(")
        if not ctor:
            ctor = in_class ? AST_Method : AST_Function

        docstring = None
        definition = new ctor({
            start: start,
            name: name,
            argnames: (def(a):
                defaults = {}
                first = True
                seen_names = {}
                def_line = S.input.context().tokline

                def get_arg():
                    if Object.prototype.hasOwnProperty.call(seen_names, S.token.value):
                        token_error(prev(), "Can't repeat parameter names")
                    if S.token.value is 'arguments':
                        token_error(prev(), "Can't use the name arguments as a parameter name, it is reserved by JavaScript")
                    seen_names[S.token.value] = True
                    # save these in order to move back if we have an annotation
                    name_token = S.token
                    name_ctx = S.input.context()
                    # check if we have an argument annotation
                    ntok = peek()
                    if ntok.type is 'punc' and ntok.value is ':':
                        # arg:Annotation
                        next()
                        expect(':')
                        annotation = maybe_conditional()

                        # and now, do as_symbol without the next() at the end
                        # since we are already at the next comma (or end bracket)
                        if not is_token(name_token, "name"):
                            # assuming the previous context in case
                            # the annotation was over the line
                            croak("Name expected", name_ctx.tokline)
                            return None

                        sym = new AST_SymbolFunarg({
                            'name': name_token.value,
                            'start': S.token,
                            'end': S.token,
                            'annotation': annotation ? new AST_Annotation({
                                'start': annotation.start,
                                'expression': annotation,
                                'end': annotation.end
                            }) : None
                        })
                    else:
                        # arg (no annotation)
                        if not is_("name"):
                            # there is no name, which is an error we should report on the
                            # same line as the definition, so move to that is we're not already there.
                            if S.input.context().tokline is not def_line:
                                croak("Name expected", def_line)
                            else:
                                croak("Name expected")
                            return None

                        sym = new AST_SymbolFunarg({
                            'name': S.token.value,
                            'start': S.token,
                            'end': S.token,
                            'annotation': None
                        })
                        next()
                    function_args[sym.name] = sym.annotation ? sym.annotation.resolveType(S.in_scope) : '?'
                    return sym

                while not is_("punc", ")"):
                    if first:
                        first = False
                    else:
                        expect(",")
                    if is_('operator', '**'):

                        # FIXME: temporary assertion while I get the logic tested and out the door
                        token_error(prev(), "**kwargs in function definition is not implemented yet, work in progress")

                        # **kwargs
                        next()
                        if a.kwargs:
                            token_error(prev(), "Can't define multiple **kwargs in function definition")
                        a.kwargs = get_arg()
                    elif is_('operator', '*'):
                        # *args
                        next()
                        if a.starargs:
                            token_error(prev(), "Can't define multiple *args in function definition")
                        if a.kwargs:
                            token_error(prev(), "Can't define *args after **kwargs in function definition")
                        a.starargs = get_arg()
                    else:
                        if a.starargs or a.kwargs:
                            token_error(prev(), "Can't define a formal parameter after *args or **kwargs")
                        a.push(get_arg())
                        if is_("operator", "="):
                            if a.kwargs:
                                token_error(prev(), "Can't define an optional formal parameter after **kwargs")
                            val = prev().value
                            next()
                            defaults[val] = expression(False)
                            a.has_defaults = True
                        else:
                            if a.has_defaults:
                                token_error(prev(), "Can't define required formal parameters after optional formal parameters")

                next()
                # check if we have a return type annotation
                if is_("punc", "->"):
                    next()
                    nonlocal return_annotation
                    # return_annotation = expression(True)
                    expr = expression(True)
                    return_annotation = new AST_Annotation({
                        start: expr.start,
                        expression: expr,
                        end: expr.end
                    })
                a.defaults = defaults
                return a
            )([]),
            decorators: (def():
                d = []
                for decorator in S.decorators:
                    d.push(new AST_Decorator({
                        expression: decorator
                    }))
                S.decorators = []
                return d
            )(),
            return_annotation: return_annotation,
            body: (def(loop, labels):
                # parse function content

                # state "push"
                S.in_scope.push({
                    type: "function",
                    name: name ? name.name : None,
                    return_annotation: return_annotation,
                    nonlocal: {},
                    vars: {},
                    args: function_args,
                    functions: {},
                    classes: {}
                })
                S.in_directives = True
                S.in_loop = 0
                S.labels = []

                a = block_()

                # these transform variables that are used by other keys, hence the somewhat ugly use of nonlocal
                nonlocal generator, localvars, docstring
                generator = S.in_scope[-1].generator
                docstring = S.in_scope[-1].docstring

                # FIXME: debug logic
                if generator:
                    print(S.in_scope[-1])

                localvars = [new_symbol(AST_SymbolVar, variable) for variable in Object.keys(S.in_scope[-1].vars) if variable not in S.in_scope[-1].nonlocal]

                # state "pop"
                S.in_scope.pop()
                S.in_loop = loop
                S.labels = labels

                return a
            )(S.in_loop, S.labels),
            docstring: docstring,
            generator: generator,
            localvars: localvars,
            end: prev(),
            static: in_class and staticmethod
        })

        if name:    # track this function in local scope
            S.in_scope[-1].functions[name.name] = definition.resolveType(S.in_scope)

        # do a few extra safety checks on arguments
        if in_class and not staticmethod:
            if definition.argnames.length < 1:
                croak("Class methods require at least one argument (self)", start.line, start.col, start.pos)
            elif ctor is AST_ObjectGetter and definition.argnames.length is not 1:
                croak("Class getters don't take any arguments aside from one referencing the instance (self)", start.line, start.col, start.pos)
            elif ctor is AST_ObjectSetter and definition.argnames.length is not 2:
                croak("Class setters take exactly 2 arguments (self, value)", start.line, start.col, start.pos)
        elif is_accessor:
            if ctor is AST_ObjectGetter and definition.argnames.length:
                croak("Object getters don't take any arguments", start.line, start.col, start.pos)
            elif ctor is AST_ObjectSetter and definition.argnames.length is not 1:
                croak("Object setters take exactly 1 argument", start.line, start.col, start.pos)

        return definition

    def accessor_(type, start, in_class):
        if type is "get":
            func = function_(in_class, AST_ObjectGetter)
        elif type is "set":
            func = function_(in_class, AST_ObjectSetter)
        else:
            croak("Expecting setter/getter, got '" + type + "' instead.")
        func.start = start
        func.end = prev()
        return func

    def if_():
        cond = expression(True)
        body = statement()
        belse = None
        if is_("keyword", "elif") or is_("keyword", "else"):
            if is_("keyword", "else"):
                next()
            else:
                S.token.value = "if"
            # effectively converts 'elif' to 'else if'
            belse = statement()

        return new AST_If({
            condition: cond,
            body: body,
            alternative: belse
        })

    def is_docstring(stmt):
        if isinstance(stmt, AST_Directive) and not S.in_scope[-1].docstring:
            return True
        return False

    def format_docstring(string):
        lines = string.split(/\n/g)

        # determine minimum indentation (first line doesn't count):
        indent = 1e6
        for line in lines[1:]:
            if line.trim().length:
                pad = line.match(/^\s*/)[0]
                indent = Math.min(indent, pad.length)

        # remove indentation (first line is special):
        trimmed = [lines[0].trim()]
        if indent < 1e6:
            for line in lines[1:]:
                trimmed.push(line[indent:].replace(/\s+$/))

        # strip off trailing and leading blank lines:
        while trimmed and not trimmed[-1]:
            trimmed.pop()
        while trimmed and not trimmed[0]:
            trimmed.shift()
        return trimmed.join('\n')

    def block_():
        expect(":")
        a = []
        if not S.token.newline_before:
            while not S.token.newline_before:
                if is_("eof"):
                    unexpected()
                stmt = statement()
                if not a.length and is_docstring(stmt):
                    # first statement is a docstring
                    S.in_scope[-1].docstring = format_docstring(stmt.value)
                else:
                    a.push(stmt)
        else:
            while not is_("punc", "}"):
                if is_("eof"):
                    # end of file, terminate block automatically
                    return a
                stmt = statement()
                if not a.length and is_docstring(stmt):
                    # first statement is a docstring
                    S.in_scope[-1].docstring = format_docstring(stmt.value)
                else:
                    a.push(stmt)
            next()
        return a

    def switch_body_():
        expect("{")
        a = []
        cur = None
        branch = None

        while not is_("punc", "}"):
            if is_("eof"):
                unexpected()

            if is_("keyword", "case"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Case({
                    start: (def():
                        tmp = S.token
                        next()
                        return tmp
                    )(),
                    expression: expression(True),
                    body: cur
                })
                a.push(branch)
                expect(":")
            elif is_("keyword", "default"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Default({
                    start: (def():
                        tmp = S.token
                        next()
                        expect(":")
                        return tmp
                    )(),
                    body: cur
                })
                a.push(branch)
            else:
                if not cur:
                    unexpected()
                cur.push(statement())

        if branch:
            branch.end = prev()
        next()
        return a

    def try_():
        body = block_()
        bcatch = []
        bfinally = None
        while is_("keyword", "except"):
            start = S.token
            next()
            exceptions = []
            if not is_("punc", ":") and not is_("keyword", "as"):
                exceptions.push(as_symbol(AST_SymbolVar))
                while is_("punc", ","):
                    next()
                    exceptions.push(as_symbol(AST_SymbolVar))

            name = None
            if is_("keyword", "as"):
                next()
                name = as_symbol(AST_SymbolCatch)

            bcatch.push(new AST_Except({
                start: start,
                argname: name,
                errors: exceptions,
                body: block_(),
                end: prev()
            }))

        if is_("keyword", "finally"):
            start = S.token
            next()
            bfinally = new AST_Finally({
                start: start,
                body: block_(),
                end: prev()
            })

        if not bcatch.length and not bfinally:
            croak("Missing except/finally blocks")

        return new AST_Try({
            body: body,
            bcatch: (bcatch.length ? new AST_Catch({
                body: bcatch
            }) : None),
            bfinally: bfinally
        })

    def vardefs(no_in, type):
        a = []
        while True:
            symbol = new AST_VarDef({
                start: S.token,
                name: as_symbol(type is "const" ? AST_SymbolConst : type is "nonlocal" ? AST_SymbolNonlocal : AST_SymbolVar),
                end: prev()
            })
            if type is "nonlocal": S.in_scope[-1].nonlocal[symbol.name.name] = True
            a.push(symbol)
            if not is_("punc", ","):
                break
            next()

        return a

    def nonlocal_(no_in):
        return new AST_Var({
            start: prev(),
            definitions: vardefs(no_in, "nonlocal"),
            end: prev()
        })

    def const_():
        return new AST_Const({
            start: prev(),
            definitions: vardefs(False, "const"),
            end: prev()
        })

    def new_():
        start = S.token
        expect_token("operator", "new")
        newexp = expr_atom(False)

        if is_("punc", "("):
            next()
            args = expr_list(")")
        else:
            args = []

        return subscripts(new AST_New({
            start: start,
            expression: newexp,
            args: args,
            end: prev()
        }), True)

    def as_atom_node(token):
        tok = token or S.token
        tmp_ = tok.type
        if tmp_ is "name":
            if tok.value is 'NaN':
                ret = as_symbol(AST_NaN, token=tok)
            elif tok.value is 'undefined':
                ret = as_symbol(AST_Undefined, token=tok)
            else:
                ret = as_symbol(AST_SymbolRef, token=tok)
        elif tmp_ is "num":
            ret = new AST_Number({
                start: tok,
                end: tok,
                value: tok.value
            })
        elif tmp_ is "string":
            ret = new AST_String({
                start: tok,
                end: tok,
                value: tok.value,
                modifier: tok.subtype
            })
        elif tmp_ is "regexp":
            ret = new AST_RegExp({
                start: tok,
                end: tok,
                value: tok.value
            })
        elif tmp_ is "atom":
            tmp__ = tok.value
            if tmp__ is "False":
                ret = new AST_False({
                    start: tok,
                    end: tok
                })
            elif tmp__ is "True":
                ret = new AST_True({
                    start: tok,
                    end: tok
                })
            elif tmp__ is "None":
                ret = new AST_Null({
                    start: tok,
                    end: tok
                })

        if not token:
            next()

        ret.resolveType(S.in_scope) # provides more context for output later
        return ret

    def expr_atom(allow_calls):
        if is_("operator", "new"):
            return new_()

        start = S.token
        if is_("punc"):
            tmp_ = start.value
            if tmp_ is "(":
                next()
                ex = expression(True)
                ex.start = start
                ex.end = S.token
                if isinstance(ex, AST_SymbolRef):
                    ex.parens = True
                expect(")")
                return subscripts(ex, allow_calls)
            elif tmp_ is "[":
                return subscripts(array_(), allow_calls)
            elif tmp_ is "{":
                return subscripts(object_(), allow_calls)

            unexpected()

        if is_("keyword", "class"):
            next()
            cls = class_()
            cls.start = start
            cls.end = prev()
            return subscripts(cls, allow_calls)

        if is_("keyword", "def"):
            next()
            func = function_(False)
            func.start = start
            func.end = prev()
            return subscripts(func, allow_calls)

        if ATOMIC_START_TOKEN[S.token.type]:
            return subscripts(as_atom_node(), allow_calls)

        unexpected()

    def expr_list(closing, allow_trailing_comma, allow_empty, func_call):
        first = True
        a = []
        saw_starargs = False
        while not is_("punc", closing):
            if saw_starargs:
                token_error(prev(), "*args must be the last argument in a function call")

            if first:
                first = False
            else:
                expect(",")
            if allow_trailing_comma and is_("punc", closing):
                break

            if is_("operator", "*") and func_call:
                saw_starargs = True
                next()

            if is_("punc", ",") and allow_empty:
                a.push(new AST_Hole({
                    start: S.token,
                    end: S.token
                }))
            else:
                a.push(expression(False))

        if func_call:
            tmp = []
            tmp.kwargs = []
            for i, arg in enumerate(a):
                if isinstance(arg, AST_Assign):
                    # arg=val
                    BASELIB['kwargs'] = True
                    tmp.kwargs.push([arg.left, arg.right])
                else:
                    # regular argument
                    tmp.push(arg)
            a = tmp

        next()
        if saw_starargs:
            a.starargs = True
        return a

    def func_call_list():
        a = []
        first = True
        a.kwargs = []
        a.kwarg_items = kwargs = []
        a.starargs = False
        while not is_("punc", ')'):
            if first:
                first = False
            else:
                expect(",")
            if is_('operator', '*'):
                # starargs argument
                next()
                arg = expression(False)
                arg.is_array = True
                a.push(arg)
                a.starargs = True
            elif is_('operator', '**'):
                # kwargs argument
                BASELIB['kwargs'] = True
                next()
                kwargs.push(as_symbol(AST_SymbolVar, False))
            else:
                # arg=val assignment
                arg = expression(False)
                if isinstance(arg, AST_Assign):
                    BASELIB['kwargs'] = True
                    a.kwargs.push([arg.left, arg.right])
                else:
                    a.push(arg)
        next()
        return a

    def read_comprehension(object):
        # shared by list and dict comprehensions
        terminator = isinstance(object, AST_DictComprehension) ? '}' : ']'
        expect_token('keyword', 'for')
        forloop = for_(True)
        BASELIB["iterable"] = True
        object.init = forloop.init
        object.name = forloop.name
        object.object = forloop.object
        object.condition = is_("punc", terminator) ? None : (expect_token("keyword", "if"), expression(True))
        expect(terminator)
        return object

    @embed_tokens
    def array_():
        expect("[")
        expr = []
        if not is_("punc", "]"):
            expr.push(expression(False))
            if is_("keyword", "for"):
                # list comprehension
                return read_comprehension(new AST_ListComprehension({ statement: expr[0] }))

            if is_("operator", "til"):
                # up to but not including upper limit
                BASELIB['range'] = True
                next()
                expr.push(expression(False))
#                ret = subscripts(new AST_Call({
#                    start: S.token,
#                    expression: new AST_SymbolRef({
#                        name: "range"
#                    }),
#                    args: expr,
#                    end: prev()
#                }), True)
                ret = new AST_Range({
                    start: S.token,
                    left: expr[0],
                    operator: "til",
                    right: expr[1],
                    end: prev()
                })
                expect("]")
                return ret
            elif is_("operator", "to"):
                # now add a tiny number to make sure we include the upper limit
                BASELIB['range'] = True
                next()
                expr.push(expression(False))
                ret = new AST_Range({
                    start: S.token,
                    left: expr[0],
                    operator: "to",
                    right: expr[1],
                    end: prev()
                })
                expect("]")
                return ret
            elif not is_("punc", "]"):
                expect(",")

        return new AST_Array({
            elements: expr.concat(expr_list("]", not options.strict, True))
        })

    @embed_tokens
    def object_():
        maybe_dict_comprehension = False
        expect("{")
        first = True
        a = []
        while not is_("punc", "}"):
            if not first:
                expect(",")
            if not options.strict and is_("punc", "}"):
                # allow trailing comma
                break

            start = S.token
            type = start.type
            computed = False
            saw_starargs = False
            if is_("operator", "*"):
                # spread operator
                saw_starargs = True
                if not options.es6:
                    croak("Spread operator in object literals is only allowed in ES6 mode")
                a.push(maybe_unary(True))
            elif first and peek().value is not ':':
                # possibly dict comprehension
                maybe_dict_comprehension = True
                key = expression(False)
                name = None
            else:
                ctx = S.input.context()
                orig = ctx.expect_object_literal_key
                ctx.expect_object_literal_key = True
                if is_("punc", "("):
                    # computed key
                    if not options.es6:
                        croak("Computed properties are only allowed in ES6 mode")
                    expect('(')
                    key = expression(False)
                    expect(')')
                    computed = True
                else:
                    # regular key
                    key_ = as_property_name()
                    name = key_.value
                    if key_.type is "num":
                        key = new AST_Number({
                            start: start,
                            value: name,
                            end: prev()
                        })
                    elif key_.type is "name" or key_.type is "keyword":
                        if name in ["True", "False"]:
                            key = new AST_Boolean({
                                start: start,
                                value: name,
                                end: prev()
                            })
                        else:
                            key = new AST_Identifier({
                                start: start,
                                value: name,
                                end: prev()
                            })
                    else:
                        key = new AST_String({
                            start: start,
                            value: name,
                            end: prev()
                        })
                ctx.expect_object_literal_key = orig

                if type is "name" and not is_("punc", ":"):
                    a.push(accessor_(name, start, False))
                    continue

            if not saw_starargs:
                expect(":")

                a.push(new AST_ObjectKeyVal({
                    start: start,
                    key: key,
                    value: expression(False),
                    end: prev()
                }))

                if a.length is 1 and is_('keyword', 'for'):
                    return read_comprehension(new AST_DictComprehension({
                        statement: maybe_dict_comprehension ? key : as_atom_node(a[0].start),
                        value_statement: a[0].value
                    }))

            first = False

        next()
        return new AST_Object({
            properties: a
        })

    def as_property_name():
        tmp = S.token
        next()
        tmp_ = tmp.type
        if tmp_ is "num" or tmp_ is "string" or tmp_ is "name" or tmp_ is "operator" or tmp_ is "keyword" or tmp_ is "atom":
            return tmp
        else:
            unexpected()

    def as_name():
        tmp = S.token
        next()
        tmp_ = tmp.type
        if tmp_ is "name" or tmp_ is "operator" or tmp_ is "keyword" or tmp_ is "atom":
            return tmp.value
        else:
            unexpected()

    def as_symbol(type, noerror, token):
        token_ = token or S.token
        if not is_token(token_, "name"):
            if not noerror:
                croak("Name expected")
            return None

        name = token_.value
        sym = new (name is "this" ? AST_This : type)({
            name: (String)(token_.value),
            start: token_,
            end: token_
        })
        if not token:
            next()
        return sym

    # for generating/inserting a new symbol
    def new_symbol(type, name):
        sym = new (name is "this" ? AST_This : type)({
            name: (String)(name),
            start: None,
            end: None
        })
        return sym

    def is_static_method(cls, method):
        if method in COMMON_STATIC or cls.static and method in cls.static:
            return True
        else:
            return False

    def mark_local_assignment(element, value):
        if value:
            computedType = type(value) is "string" ? value : value.resolveType(S.in_scope)
        else:
            computedType = "?"

        name = typeof element is "string" ? element : element.name
        if name:
            # not enough information to infer type yet
            # so all types are ? for now, in the future this function will infer type from context
            # that may need some refactoring of car/cdr logic
            if name in S.in_scope[-1].vars:
                S.in_scope[-1].vars[name].push(computedType)
            else:
                S.in_scope[-1].vars[name] = [computedType]

    def subscripts(expr, allow_calls):
        start = expr.start
        if is_("punc", "."):
            next()
            return subscripts(new AST_Dot({
                start: start,
                expression: expr,
                property: as_name(),
                end: prev()
            }), allow_calls)

        if is_("punc", "[") and not S.token.newline_before:
            next()
            slice_bounds = []
            is_slice = False
            if is_("punc", ":"):
                # slice [:n]
                slice_bounds.push(None)
            else:
                # slice [n?]
                slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m?]
                is_slice = True
                next()
                if is_("punc", ":"):
                    slice_bounds.push(None)
                elif not is_("punc", "]"):
                    slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m:o?]
                BASELIB["eslice"] = True
                next()
                if is_("punc", "]"):
                    unexpected()
                else:
                    slice_bounds.push(expression(False))

            expect("]")

            if is_slice:
                if is_("operator") and S.token.value is "=":
                    # splice-assignment (arr[start:end] = ...)
                    next()  # swallow the assignment
                    return subscripts(new AST_Slice({
                        start: start,
                        expression: expr,
                        property: slice_bounds[0] or new AST_Number({
                            value: 0
                        }),
                        property2: slice_bounds[1],
                        assignment: expression(True),
                        end: prev()
                    }), allow_calls)
                elif slice_bounds.length is 3:
                    # extended slice (arr[start:end:step])
                    slice_bounds.unshift(slice_bounds.pop())
                    if not slice_bounds[-1]:
                        slice_bounds.pop()
                        if not slice_bounds[-1]:
                            slice_bounds.pop()
                    elif not slice_bounds[-2]:
                        slice_bounds[-2] = new AST_Undefined()

                    return subscripts(new AST_Call({
                        start: start,
                        expression: new AST_SymbolRef({
                            name: "eslice"
                        }),
                        args: [expr].concat(slice_bounds),
                        end: prev()
                    }), allow_calls)
                else:
                    # regular slice (arr[start:end])
                    slice_bounds = [i is None ? new AST_Number({
                        value: 0
                    }) : i for i in slice_bounds]
                    return subscripts(new AST_Call({
                        start: start,
                        expression: new AST_Dot({
                            start: start,
                            expression: expr,
                            property: "slice",
                            end: prev()
                        }),
                        args: slice_bounds,
                        end: prev()
                    }), allow_calls)
            else:
                # regular index (arr[index])
                return subscripts(new AST_Sub({
                    start: start,
                    expression: expr,
                    property: slice_bounds[0] or new AST_Number({
                        value: 0
                    }),
                    end: prev()
                }), allow_calls)

        if allow_calls and is_("punc", "(") and not S.token.newline_before:
            next()
            if isinstance(expr, AST_SymbolRef) and expr.name is "JS":
                # raw JavaScript chunk of code
                str_ = expression(False)
                if not (isinstance(str_, AST_String)):
                    token_error(prev(), "Compile-time function JS() can't evaluate variables or expressions")

                ret = new AST_Verbatim({
                    start: start,
                    value: str_.value,
                    end: prev()
                })
                expect(")")
                return subscripts(ret, True)
            elif not expr.parens and get_class_in_scope(expr):
                # this is an object being created using a class

                # check if this class is part of our standard library
                if expr.name in STDLIB:
                    BASELIB[expr.name] = True
                    if /Error$/.test(expr.name):
                        # errors are classes
                        BASELIB["extends"] = True

                return subscripts(new AST_New({
                    start: start,
                    expression: expr,
                    args: func_call_list(),
                    end: prev()
                }), True)
            else:
                if isinstance(expr, AST_Dot):
                    cls = get_class_in_scope(expr.expression)

                if cls:
                    # generate class call
                    funcname = expr
                    if funcname.property is "__init__":
                        funcname.property = "constructor"

                    return validateCallArgs(subscripts(new AST_ClassCall({
                        start: start,
                        class: expr.expression,
                        method: funcname.property,
                        super: S.in_scope.length > 1 and S.in_scope[-2].type is 'class' and expr.expression.name is S.in_scope[-2].parent,
                        static: is_static_method(cls, funcname.property),
                        args: func_call_list(),
                        end: prev()
                    }), True))
                elif isinstance(expr, AST_SymbolRef):
                    tmp_ = expr.name
                    # special functions that trigger addition of extra logic to generated JavaScript
                    if tmp_ in STDLIB:
                        BASELIB[tmp_] = True
                        # NOTE: there is intentionally no return here, we want these functions to go through regular logic
                        # after they trigger the appropriate baselib flag
                    elif tmp_ is "type":
                        return new AST_UnaryPrefix({
                            start: start,
                            operator: "typeof",
                            expression: func_call_list()[0],
                            end: prev()
                        })
                    elif tmp_ is "isinstance":
                        args = func_call_list()
                        return new AST_Binary({
                            start: start,
                            operator: "instanceof",
                            left: args[0],
                            right: args[1],
                            end: prev()
                        })

                # fall-through to basic function call
                return validateCallArgs(subscripts(new AST_Call({
                    start: start,
                    expression: expr,
                    args: func_call_list(),
                    end: prev()
                }), True))

        return expr

    def keepDecoratorOrImport(expr, imp=False):
        # helper function for figuring out whether this decorator should be dropped
        if imp:
            if not options.dropImports.length: return True
        else:
            if not options.dropDecorators.length: return True

        def stringifyName(expr):
            if isinstance(expr, AST_Dot):
                return stringifyName(expr.expression) + "." + expr.property
            return expr.name

        if type(expr) is 'string':
            # passed in a string
            name = expr
        elif isinstance(expr, AST_SymbolRef):
            # regular decorator
            name = expr.name
        elif isinstance(expr, AST_Dot):
            # dot decorator
            name = stringifyName(expr)
        elif isinstance(expr, AST_Call):
            # decorator with args
            name = stringifyName(expr.expression)
        else:
            croak("Unsupported decorator")

        if imp:
            return name not in options.dropImports
        else:
            return name not in options.dropDecorators

    def maybe_unary(allow_calls):
        start = S.token

        if is_('operator', '@'):
            if S.in_decorator:
                croak('Nested decorators are not allowed')
            next()
            S.in_decorator = True
            expr = expression()
            S.in_decorator = False
            if keepDecoratorOrImport(expr):
                S.decorators.push(expr)
            return new AST_EmptyStatement({
                stype: '@',
                start: prev(),
                end: prev()
            })

        if is_("operator") and UNARY_PREFIX(start.value):
            next()

            ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls))
            ex.start = start
            ex.end = prev()
            return ex

        val = expr_atom(allow_calls)
        while is_("operator") and UNARY_POSTFIX(S.token.value) and not S.token.newline_before:
            val = make_unary(AST_UnaryPostfix, S.token.value, val)
            val.start = start
            val.end = S.token
            next()
        return val

    def make_unary(ctor, op, expr):
        return validateUnary(new ctor({
            operator: op,
            expression: expr
        }))

    def validateBinary(astElement):
        # check for invalid operations using our knowledge of types
        # allow int + str for now
        left = astElement.left.resolveType(S.in_scope)
        right = astElement.right.resolveType(S.in_scope)
        op = astElement.operator
        # for in, instanceof, ==, !=, ===, !==, 'or', 'and', '=' everything is allowed
        # for 2 numbers any operator is valid
        # for 2 strings or number and string only the + operator is valid
        # for ?, we don't have enough information
        # for everything else, no operator is valid
        if op not in ['in', 'instanceof', '==', '!=', '===', '!==', '||', '&&', '='] and (
            left not in ['Number', 'String', 'Boolean', '?']
            or right not in ['Number', 'String', 'Boolean', '?']
            or left is 'String' and op not in ['+', '+=']
            or right is 'String' and op not in ['+', '+=']
        ):
            # make the representations a bit more human-friendly
            if left[0] is '[': left = 'Array'
            elif left[0] is '{': left = 'Object'
            if right[0] is '[': right = 'Array'
            elif right[0] is '{': right = 'Object'
            raise croak("cannot perform binary '" + op + "' operation on incompatbile elements of type " + left + " and " + right + "")
        return astElement

    def validateUnary(astElement):
        # check that the prefix is compatible with the element
        element = astElement.expression.resolveType(S.in_scope)
        op = astElement.operator
        if element not in ['Number', '?'] and op in ['+', '-'] or element[0] not in ['[', '{', '?'] and op is '*':
            # make the representations a bit more human-friendly
            if element[0] is '[': element = 'Array'
            elif element[0] is '{': element = 'Object'
            raise croak("cannot perform unary '" + op + "' operation on incompatbile element of type " + element)
        return astElement

    def validateCallArgs(astElement):
        # check that passed in arguments match function signature
        # also, let's check that we're not passing too many arguments
        if isinstance(astElement.expression, AST_SymbolRef):
            name = astElement.expression.name
            found = False
            for scope in reversed(S.in_scope):
                for func in scope.functions:
                    if func is name:
                        signature = scope.functions[func]
                        found = True
                        break
                for variable in scope.vars:
                    if variable is name:
                        signature = scope.vars[func]
                        found = True
                        break
                if found: break
            # TODO: there is a case of having found == True and signature = undefined, it shouldn't happen
            if signature and signature[:9] is 'Function(':
                # TODO: fix this, current logic naively assumes there are no nested commas
                # validate the number of args first
                args = /\((.*)\)/.exec(signature)[1].split(',')
                if args.length is 1 and not args[0].length: args.pop()
                if args.length < astElement.args.length:
                    croak("Function '" + name + "' takes " + args.length + " arguments, yet your call contains " + astElement.args.length + "")
                # now validate argument types
                for i, arg in enumerate(astElement.args):
                    expected = args[i].trim()
                    actual = arg.resolveType(S.in_scope)
                    if expected is not '?' and actual not in [expected, '?']:
                        croak("Function '" + name + "' expects argument " + i + " type of " + expected + ", but you're passing " + actual + "")
        return astElement

    def expr_op(left, min_prec, no_in):
        op = (is_("operator") ? S.token.value : None)
        not_in = False
        if op is "!" and peek().type is "operator" and peek().value is "in":
            next()
            op = "in"
            not_in = True

        if op is "in":
            if no_in:
                op = None
            else:
                BASELIB[op] = True

        prec = (op is not None ? PRECEDENCE[op] : None)
        if prec is not None and prec > min_prec:
            next()
            right = expr_op(maybe_unary(True), prec, no_in)
            if op in ['==', '!=']:
                # RapydScript's deep equality is unique to other compilers in that it has the same
                # performance (no overhead) as the naive identity operator native to JS, for that
                # reason it is now the default equality. If you wish to avoid it, use 'is' operator
                # instead
                BASELIB["eq"] = True
                ret = new AST_DeepEquality({
                    start: left.start,
                    left: left,
                    operator: op,
                    right: right,
                    end: right.end
                })
            else:
                ret = new AST_Binary({
                    start: left.start,
                    left: left,
                    operator: op,
                    right: right,
                    end: right.end
                })
                validateBinary(ret)
            if not_in:
                ret = new AST_UnaryPrefix({
                    start: left.start,
                    operator: "!",
                    expression: ret,
                    end: right.end
                })
            return expr_op(ret, min_prec, no_in)
        return left

    def expr_ops(no_in):
        return expr_op(maybe_unary(True), 0, no_in)

    def maybe_conditional(no_in):
        start = S.token
        expr = expr_ops(no_in)
        if is_("operator", "?"):
            next()
            yes = expression(False)
            expect(":")
            return new AST_Conditional({
                start: start,
                condition: expr,
                consequent: yes,
                alternative: expression(False, no_in),
                end: peek()
            })
        return expr

    def isAssignable(expr):
        # recursively checks if every element being assigned to is in fact assignable
        if isinstance(expr, AST_SymbolRef) or isinstance(expr, AST_PropAccess):
            return True
        if isinstance(expr, AST_Array):
            for element in expr.elements:
                if not isAssignable(element): return False
            return True
        if isinstance(expr, AST_Seq):
            # remind me to get rid of these AST_Seq nodes, they do more harm than good
            if isAssignable(expr.car) and isAssignable(expr.cdr): return True
        return False

    def maybe_assign(no_in):
        start = S.token
        left = maybe_conditional(no_in)
        val = S.token.value
        if is_("operator") and ASSIGNMENT(val):
            if isAssignable(left):
                if isinstance(left, AST_SymbolRef)
                and val is not "="
                and left.name not in S.in_scope[-1].vars
                and (not S.in_scope[-1].args or left.name not in S.in_scope[-1].args)
                and left.name not in S.in_scope[-1].nonlocal:
                    croak("Attempting to increment/modify uninitialized variable '" +
                        left.name + "', this can also occur if you're trying to shadow without initializing the variable in local scope.")
                next()
                right = maybe_assign(no_in)
                if not S.in_seq:
                    # regular assignment of type a = ... will be picked up here
                    # other assignments such as a, b = ..., [a, b] = ... will be picked up in sequence formation logic
                    mark_local_assignment(left, right)
                return validateBinary(new AST_Assign({
                    start: start,
                    left: left,
                    operator: val,
                    right: right,
                    end: prev()
                }))
            croak("Invalid assignment")
        return left

    def expression(commas, no_in):
        # if there is an assignment, we want the sequences to pivot
        # around it to allow for tuple packing/unpacking
        start = S.token
        expr = maybe_assign(no_in)
        if commas:
            left = [ expr ]
            while is_("punc", ",") and not peek().newline_before:
                S.in_seq = True
                next()
                if isinstance(expr, AST_Assign):
                    # AST_Seq representation is ugly to decode for
                    # assignments, let's convert data to array now
                    # to avoid dealing with it
                    left[-1] = left[-1].left
                    if left.length is 1:
                        if isinstance(left[0], AST_Seq):
                            # convert sequence to array and add every variable to local scope
                            leftAst = seq_to_array(left[0])
                        else:
                            # left[0] is already an array
                            leftAst = left[0]
                    else:
                        # left itself is an array
                        leftAst = new AST_Array({
                            elements: left
                        })

                    # this is assignment of type [a, b] = ... and (a, b) = ..., scan for local vars
                    right = seq_to_array(new AST_Seq({
                        car: expr.right,
                        cdr: expression(True, no_in)
                    }))
                    for index, element in enumerate(leftAst.elements):
                        mark_local_assignment(element, right.elements[index])

                    return new AST_Assign({
                        start: start,
                        left: leftAst,
                        operator: expr.operator,
                        right: right,
                        end: peek()
                    })

                expr = maybe_assign(no_in)
                left.push(expr)
            S.in_seq = False

            # transform assignments to (a, b, ...) into [a, b, ...]
            if isinstance(expr, AST_Assign) and isinstance(expr.left, AST_Seq):
                expr.left = seq_to_array(expr.left)

            # if last one was an assignment, fix it
            if left.length > 1 and isinstance(left[-1], AST_Assign):
                left[-1] = left[-1].left

                for index, element in enumerate(left):
                    mark_local_assignment(element, isinstance(expr.right, AST_Array) ? expr.right.elements[index] : None)

                return new AST_Assign({
                    start: start,
                    left: new AST_Array({
                        elements: left
                    }),
                    operator: expr.operator,
                    right: expr.right,
                    end: peek()
                })

            #recursive sequence formation
            seq = (def build_seq(a):
                first = a.shift()

                # this will pick up array to array assignment
                if isinstance(first, AST_Assign):
                    if isinstance(first.left, AST_Array):
                        for index, element in enumerate(first.left.elements):
                            mark_local_assignment(element, isinstance(first.right, AST_Array) ? first.right.elements[index] : None)

                if not a.length:
                    return first

                return new AST_Seq({
                    start: start,
                    car: first,
                    cdr: build_seq(a),
                    end: peek()
                })
            )(left)
            # seq.dump(3)
            # print('')
            return seq

        return expr

    def in_loop(cont):
        S.in_loop += 1
        ret = cont()
        S.in_loop -= 1
        return ret

    return (def():
        start = S.token
        body = []
        docstring = None
        first_token = True
        while not is_("eof"):
            element = statement()
            if first_token and isinstance(element, AST_Directive) and element.value.indexOf('#!') is 0:
                shebang = element.value
            elif not body.length and is_docstring(element):
                # first statement is a docstring
                docstring = format_docstring(element.value)
            else:
                body.push(element)
            first_token = False

        end = prev()
        toplevel = options.toplevel
        if toplevel:
            toplevel.body = toplevel.body.concat(body)
            toplevel.end = end
        else:
            toplevel = new AST_Toplevel({
                start: start,
                body: body,
                strict: True,
                shebang: shebang,
                docstring: docstring,
                end: end
            })

        def uniq(element, index, arr):
            return arr.lastIndexOf(element) is index

        toplevel.nonlocalvars = Object.keys(S.in_scope[-1].nonlocal)
        assignments = Object.keys(S.in_scope[-1].vars)
        callables = scan_for_top_level_callables(toplevel.body).filter(uniq)
        toplevel.localvars = []
        for item in assignments:
            if item not in toplevel.nonlocalvars:
                toplevel.localvars.push(new_symbol(AST_SymbolVar, item))
        toplevel.exports = toplevel.localvars.concat(callables).filter(uniq)
        toplevel.submodules = []
        toplevel.classes = CLASS_MAP
        toplevel.import_order = Object.keys(IMPORTED).length
        toplevel.module_id = module_id
        IMPORTED[module_id] = toplevel
        toplevel.imports = IMPORTED
        toplevel.baselib = BASELIB
        IMPORTING[module_id] = False
        return toplevel
    )()

